{"ast":null,"code":"/**\n * @import {AstPseudoClass} from 'css-selector-parser'\n * @import {default as NthCheck} from 'nth-check'\n * @import {ElementContent, Element, Parents} from 'hast'\n * @import {State} from './index.js'\n */\n\nimport { extendedFilter } from 'bcp-47-match';\nimport { parse as commas } from 'comma-separated-tokens';\nimport { ok as assert, unreachable } from 'devlop';\nimport { hasProperty } from 'hast-util-has-property';\nimport { whitespace } from 'hast-util-whitespace';\nimport fauxEsmNthCheck from 'nth-check';\nimport { zwitch } from 'zwitch';\nimport { walk } from './walk.js';\n\n/** @type {NthCheck} */\n// @ts-expect-error: types are broken.\nconst nthCheck = fauxEsmNthCheck.default || fauxEsmNthCheck;\n\n/** @type {(rule: AstPseudoClass, element: Element, index: number | undefined, parent: Parents | undefined, state: State) => boolean} */\nexport const pseudo = zwitch('name', {\n  handlers: {\n    'any-link': anyLink,\n    blank,\n    checked,\n    dir,\n    disabled,\n    empty,\n    enabled,\n    'first-child': firstChild,\n    'first-of-type': firstOfType,\n    has,\n    is,\n    lang,\n    'last-child': lastChild,\n    'last-of-type': lastOfType,\n    not,\n    'nth-child': nthChild,\n    'nth-last-child': nthLastChild,\n    'nth-last-of-type': nthLastOfType,\n    'nth-of-type': nthOfType,\n    'only-child': onlyChild,\n    'only-of-type': onlyOfType,\n    optional,\n    'read-only': readOnly,\n    'read-write': readWrite,\n    required,\n    root,\n    scope\n  },\n  invalid: invalidPseudo,\n  unknown: unknownPseudo\n});\n\n/**\n * Check whether an element matches an `:any-link` pseudo.\n *\n * @param {AstPseudoClass} _\n *   Query.\n * @param {Element} element\n *   Element.\n * @returns {boolean}\n *   Whether `element` matches `query`.\n */\nfunction anyLink(_, element) {\n  return (element.tagName === 'a' || element.tagName === 'area' || element.tagName === 'link') && hasProperty(element, 'href');\n}\n\n/**\n * @param {State} state\n *   State.\n * @param {AstPseudoClass} query\n *   Query.\n */\nfunction assertDeep(state, query) {\n  if (state.shallow) {\n    throw new Error('Cannot use `:' + query.name + '` without parent');\n  }\n}\n\n/**\n * Check whether an element matches a `:blank` pseudo.\n *\n * @param {AstPseudoClass} _\n *   Query.\n * @param {Element} element\n *   Element.\n * @returns {boolean}\n *   Whether `element` matches `query`.\n */\nfunction blank(_, element) {\n  return !someChildren(element, check);\n\n  /**\n   * @param {ElementContent} child\n   * @returns {boolean}\n   */\n  function check(child) {\n    return child.type === 'element' || child.type === 'text' && !whitespace(child);\n  }\n}\n\n/**\n * Check whether an element matches a `:checked` pseudo.\n *\n * @param {AstPseudoClass} _\n *   Query.\n * @param {Element} element\n *   Element.\n * @returns {boolean}\n *   Whether `element` matches `query`.\n */\nfunction checked(_, element) {\n  if (element.tagName === 'input' || element.tagName === 'menuitem') {\n    return Boolean((element.properties.type === 'checkbox' || element.properties.type === 'radio') && hasProperty(element, 'checked'));\n  }\n  if (element.tagName === 'option') {\n    return hasProperty(element, 'selected');\n  }\n  return false;\n}\n\n/**\n * Check whether an element matches a `:dir()` pseudo.\n *\n * @param {AstPseudoClass} query\n *   Query.\n * @param {Element} _1\n *   Element.\n * @param {number | undefined} _2\n *   Index of `element` in `parent`.\n * @param {Parents | undefined} _3\n *   Parent of `element`.\n * @param {State} state\n *   State.\n * @returns {boolean}\n *   Whether `element` matches `query`.\n */\n// eslint-disable-next-line unicorn/prevent-abbreviations\nfunction dir(query, _1, _2, _3, state) {\n  assert(query.argument, 'expected `argument`');\n  assert(query.argument.type === 'String', 'expected plain text');\n  return state.direction === query.argument.value;\n}\n\n/**\n * Check whether an element matches a `:disabled` pseudo.\n *\n * @param {AstPseudoClass} _\n *   Query.\n * @param {Element} element\n *   Element.\n * @returns {boolean}\n *   Whether `element` matches `query`.\n */\nfunction disabled(_, element) {\n  return (element.tagName === 'button' || element.tagName === 'input' || element.tagName === 'select' || element.tagName === 'textarea' || element.tagName === 'optgroup' || element.tagName === 'option' || element.tagName === 'menuitem' || element.tagName === 'fieldset') && hasProperty(element, 'disabled');\n}\n\n/**\n * Check whether an element matches an `:empty` pseudo.\n *\n * @param {AstPseudoClass} _\n *   Query.\n * @param {Element} element\n *   Element.\n * @returns {boolean}\n *   Whether `element` matches `query`.\n */\nfunction empty(_, element) {\n  return !someChildren(element, check);\n\n  /**\n   * @param {ElementContent} child\n   * @returns {boolean}\n   */\n  function check(child) {\n    return child.type === 'element' || child.type === 'text';\n  }\n}\n\n/**\n * Check whether an element matches an `:enabled` pseudo.\n *\n * @param {AstPseudoClass} query\n *   Query.\n * @param {Element} element\n *   Element.\n * @returns {boolean}\n *   Whether `element` matches `query`.\n */\nfunction enabled(query, element) {\n  return !disabled(query, element);\n}\n\n/**\n * Check whether an element matches a `:first-child` pseudo.\n *\n * @param {AstPseudoClass} query\n *   Query.\n * @param {Element} _1\n *   Element.\n * @param {number | undefined} _2\n *   Index of `element` in `parent`.\n * @param {Parents | undefined} _3\n *   Parent of `element`.\n * @param {State} state\n *   State.\n * @returns {boolean}\n *   Whether `element` matches `query`.\n */\nfunction firstChild(query, _1, _2, _3, state) {\n  assertDeep(state, query);\n  return state.elementIndex === 0;\n}\n\n/**\n * Check whether an element matches a `:first-of-type` pseudo.\n *\n * @param {AstPseudoClass} query\n *   Query.\n * @param {Element} _1\n *   Element.\n * @param {number | undefined} _2\n *   Index of `element` in `parent`.\n * @param {Parents | undefined} _3\n *   Parent of `element`.\n * @param {State} state\n *   State.\n * @returns {boolean}\n *   Whether `element` matches `query`.\n */\nfunction firstOfType(query, _1, _2, _3, state) {\n  assertDeep(state, query);\n  return state.typeIndex === 0;\n}\n\n/**\n * @param {AstPseudoClass} query\n *   Query.\n * @returns {(value: number) => boolean}\n *   N.\n */\nfunction getCachedNthCheck(query) {\n  /** @type {(value: number) => boolean} */\n  // @ts-expect-error: cache.\n  let cachedFunction = query._cachedFn;\n  if (!cachedFunction) {\n    const value = query.argument;\n    assert(value, 'expected `argument`');\n    if (value.type !== 'Formula') {\n      throw new Error('Expected `nth` formula, such as `even` or `2n+1` (`of` is not yet supported)');\n    }\n    cachedFunction = nthCheck(value.a + 'n+' + value.b);\n    // @ts-expect-error: cache.\n    query._cachedFn = cachedFunction;\n  }\n  return cachedFunction;\n}\n\n/**\n * @param {AstPseudoClass} query\n *   Query.\n * @param {Element} element\n *   Element.\n * @param {number | undefined} _1\n *   Index of `element` in `parent`.\n * @param {Parents | undefined} _2\n *   Parent of `element`.\n * @param {State} state\n *   State.\n * @returns {boolean}\n *   Whether `element` matches `query`.\n */\nfunction has(query, element, _1, _2, state) {\n  assert(query.argument, 'expected `argument`');\n  assert(query.argument.type === 'Selector', 'expected selector');\n\n  /** @type {State} */\n  const childState = {\n    ...state,\n    // Not found yet.\n    found: false,\n    // One result is enough.\n    one: true,\n    results: [],\n    rootQuery: query.argument,\n    scopeElements: [element],\n    // Do walk deep.\n    shallow: false\n  };\n  walk(childState, {\n    type: 'root',\n    children: element.children\n  });\n  return childState.results.length > 0;\n}\n\n// Shouldn’t be called, parser gives correct data.\n/* c8 ignore next 3 */\nfunction invalidPseudo() {\n  unreachable('Invalid pseudo-selector');\n}\n\n/**\n * Check whether an element `:is` further selectors.\n *\n * @param {AstPseudoClass} query\n *   Query.\n * @param {Element} element\n *   Element.\n * @param {number | undefined} _1\n *   Index of `element` in `parent`.\n * @param {Parents | undefined} _2\n *   Parent of `element`.\n * @param {State} state\n *   State.\n * @returns {boolean}\n *   Whether `element` matches `query`.\n */\nfunction is(query, element, _1, _2, state) {\n  assert(query.argument, 'expected `argument`');\n  assert(query.argument.type === 'Selector', 'expected selector');\n\n  /** @type {State} */\n  const childState = {\n    ...state,\n    // Not found yet.\n    found: false,\n    // One result is enough.\n    one: true,\n    results: [],\n    rootQuery: query.argument,\n    scopeElements: [element],\n    // Do walk deep.\n    shallow: false\n  };\n  walk(childState, element);\n  return childState.results[0] === element;\n}\n\n/**\n * Check whether an element matches a `:lang()` pseudo.\n *\n * @param {AstPseudoClass} query\n *   Query.\n * @param {Element} _1\n *   Element.\n * @param {number | undefined} _2\n *   Index of `element` in `parent`.\n * @param {Parents | undefined} _3\n *   Parent of `element`.\n * @param {State} state\n *   State.\n * @returns {boolean}\n *   Whether `element` matches `query`.\n */\nfunction lang(query, _1, _2, _3, state) {\n  assert(query.argument, 'expected `argument`');\n  assert(query.argument.type === 'String', 'expected string');\n  return state.language !== '' && state.language !== undefined && extendedFilter(state.language, commas(query.argument.value)).length > 0;\n}\n\n/**\n * Check whether an element matches a `:last-child` pseudo.\n *\n * @param {AstPseudoClass} query\n *   Query.\n * @param {Element} _1\n *   Element.\n * @param {number | undefined} _2\n *   Index of `element` in `parent`.\n * @param {Parents | undefined} _3\n *   Parent of `element`.\n * @param {State} state\n *   State.\n * @returns {boolean}\n *   Whether `element` matches `query`.\n */\nfunction lastChild(query, _1, _2, _3, state) {\n  assertDeep(state, query);\n  return Boolean(state.elementCount && state.elementIndex === state.elementCount - 1);\n}\n\n/**\n * Check whether an element matches a `:last-of-type` pseudo.\n *\n * @param {AstPseudoClass} query\n *   Query.\n * @param {Element} _1\n *   Element.\n * @param {number | undefined} _2\n *   Index of `element` in `parent`.\n * @param {Parents | undefined} _3\n *   Parent of `element`.\n * @param {State} state\n *   State.\n * @returns {boolean}\n *   Whether `element` matches `query`.\n */\nfunction lastOfType(query, _1, _2, _3, state) {\n  assertDeep(state, query);\n  return typeof state.typeIndex === 'number' && typeof state.typeCount === 'number' && state.typeIndex === state.typeCount - 1;\n}\n\n/**\n * Check whether an element does `:not` match further selectors.\n *\n * @param {AstPseudoClass} query\n *   Query.\n * @param {Element} element\n *   Element.\n * @param {number | undefined} index\n *   Index of `element` in `parent`.\n * @param {Parents | undefined} parent\n *   Parent of `element`.\n * @param {State} state\n *   State.\n * @returns {boolean}\n *   Whether `element` matches `query`.\n */\nfunction not(query, element, index, parent, state) {\n  return !is(query, element, index, parent, state);\n}\n\n/**\n * Check whether an element matches an `:nth-child` pseudo.\n *\n * @param {AstPseudoClass} query\n *   Query.\n * @param {Element} _1\n *   Element.\n * @param {number | undefined} _2\n *   Index of `element` in `parent`.\n * @param {Parents | undefined} _3\n *   Parent of `element`.\n * @param {State} state\n *   State.\n * @returns {boolean}\n *   Whether `element` matches `query`.\n */\nfunction nthChild(query, _1, _2, _3, state) {\n  const cachedFunction = getCachedNthCheck(query);\n  assertDeep(state, query);\n  return typeof state.elementIndex === 'number' && cachedFunction(state.elementIndex);\n}\n\n/**\n * Check whether an element matches an `:nth-last-child` pseudo.\n *\n * @param {AstPseudoClass} query\n *   Query.\n * @param {Element} _1\n *   Element.\n * @param {number | undefined} _2\n *   Index of `element` in `parent`.\n * @param {Parents | undefined} _3\n *   Parent of `element`.\n * @param {State} state\n *   State.\n * @returns {boolean}\n *   Whether `element` matches `query`.\n */\nfunction nthLastChild(query, _1, _2, _3, state) {\n  const cachedFunction = getCachedNthCheck(query);\n  assertDeep(state, query);\n  return Boolean(typeof state.elementCount === 'number' && typeof state.elementIndex === 'number' && cachedFunction(state.elementCount - state.elementIndex - 1));\n}\n\n/**\n * Check whether an element matches a `:nth-last-of-type` pseudo.\n *\n * @param {AstPseudoClass} query\n *   Query.\n * @param {Element} _1\n *   Element.\n * @param {number | undefined} _2\n *   Index of `element` in `parent`.\n * @param {Parents | undefined} _3\n *   Parent of `element`.\n * @param {State} state\n *   State.\n * @returns {boolean}\n *   Whether `element` matches `query`.\n */\nfunction nthLastOfType(query, _1, _2, _3, state) {\n  const cachedFunction = getCachedNthCheck(query);\n  assertDeep(state, query);\n  return typeof state.typeCount === 'number' && typeof state.typeIndex === 'number' && cachedFunction(state.typeCount - 1 - state.typeIndex);\n}\n\n/**\n * Check whether an element matches an `:nth-of-type` pseudo.\n *\n * @param {AstPseudoClass} query\n *   Query.\n * @param {Element} _1\n *   Element.\n * @param {number | undefined} _2\n *   Index of `element` in `parent`.\n * @param {Parents | undefined} _3\n *   Parent of `element`.\n * @param {State} state\n *   State.\n * @returns {boolean}\n *   Whether `element` matches `query`.\n */\nfunction nthOfType(query, _1, _2, _3, state) {\n  const cachedFunction = getCachedNthCheck(query);\n  assertDeep(state, query);\n  return typeof state.typeIndex === 'number' && cachedFunction(state.typeIndex);\n}\n\n/**\n * Check whether an element matches an `:only-child` pseudo.\n *\n * @param {AstPseudoClass} query\n *   Query.\n * @param {Element} _1\n *   Element.\n * @param {number | undefined} _2\n *   Index of `element` in `parent`.\n * @param {Parents | undefined} _3\n *   Parent of `element`.\n * @param {State} state\n *   State.\n * @returns {boolean}\n *   Whether `element` matches `query`.\n */\nfunction onlyChild(query, _1, _2, _3, state) {\n  assertDeep(state, query);\n  return state.elementCount === 1;\n}\n\n/**\n * Check whether an element matches an `:only-of-type` pseudo.\n *\n * @param {AstPseudoClass} query\n *   Query.\n * @param {Element} _1\n *   Element.\n * @param {number | undefined} _2\n *   Index of `element` in `parent`.\n * @param {Parents | undefined} _3\n *   Parent of `element`.\n * @param {State} state\n *   State.\n * @returns {boolean}\n *   Whether `element` matches `query`.\n */\nfunction onlyOfType(query, _1, _2, _3, state) {\n  assertDeep(state, query);\n  return state.typeCount === 1;\n}\n\n/**\n * Check whether an element matches an `:optional` pseudo.\n *\n * @param {AstPseudoClass} query\n *   Query.\n * @param {Element} element\n *   Element.\n * @returns {boolean}\n *   Whether `element` matches `query`.\n */\nfunction optional(query, element) {\n  return !required(query, element);\n}\n\n/**\n * Check whether an element matches a `:read-only` pseudo.\n *\n * @param {AstPseudoClass} query\n *   Query.\n * @param {Element} element\n *   Element.\n * @param {number | undefined} index\n *   Index of `element` in `parent`.\n * @param {Parents | undefined} parent\n *   Parent of `element`.\n * @param {State} state\n *   State.\n * @returns {boolean}\n *   Whether `element` matches `query`.\n */\nfunction readOnly(query, element, index, parent, state) {\n  return !readWrite(query, element, index, parent, state);\n}\n\n/**\n * Check whether an element matches a `:read-write` pseudo.\n *\n * @param {AstPseudoClass} _\n *   Query.\n * @param {Element} element\n *   Element.\n * @param {number | undefined} _1\n *   Index of `element` in `parent`.\n * @param {Parents | undefined} _2\n *   Parent of `element`.\n * @param {State} state\n *   State.\n * @returns {boolean}\n *   Whether `element` matches `query`.\n */\nfunction readWrite(_, element, _1, _2, state) {\n  return element.tagName === 'input' || element.tagName === 'textarea' ? !hasProperty(element, 'readOnly') && !hasProperty(element, 'disabled') : Boolean(state.editableOrEditingHost);\n}\n\n/**\n * Check whether an element matches a `:required` pseudo.\n *\n * @param {AstPseudoClass} _\n *   Query.\n * @param {Element} element\n *   Element.\n * @returns {boolean}\n *   Whether `element` matches `query`.\n */\nfunction required(_, element) {\n  return (element.tagName === 'input' || element.tagName === 'textarea' || element.tagName === 'select') && hasProperty(element, 'required');\n}\n\n/**\n * Check whether an element matches a `:root` pseudo.\n *\n * @param {AstPseudoClass} _1\n *   Query.\n * @param {Element} element\n *   Element.\n * @param {number | undefined} _2\n *   Index of `element` in `parent`.\n * @param {Parents | undefined} parent\n *   Parent of `element`.\n * @param {State} state\n *   State.\n * @returns {boolean}\n *   Whether `element` matches `query`.\n */\nfunction root(_1, element, _2, parent, state) {\n  return Boolean((!parent || parent.type === 'root') && state.schema && (state.schema.space === 'html' || state.schema.space === 'svg') && (element.tagName === 'html' || element.tagName === 'svg'));\n}\n\n/**\n * Check whether an element matches a `:scope` pseudo.\n *\n * @param {AstPseudoClass} _1\n *   Query.\n * @param {Element} element\n *   Element.\n * @param {number | undefined} _2\n *   Index of `element` in `parent`.\n * @param {Parents | undefined} _3\n *   Parent of `element`.\n * @param {State} state\n *   State.\n * @returns {boolean}\n *   Whether `element` matches `query`.\n */\nfunction scope(_1, element, _2, _3, state) {\n  return state.scopeElements.includes(element);\n}\n\n/**\n * Check children.\n *\n * @param {Element} element\n *   Element.\n * @param {(child: ElementContent) => boolean} check\n *   Check.\n * @returns {boolean}\n *   Whether a child of `element` matches `check`.\n */\nfunction someChildren(element, check) {\n  const children = element.children;\n  let index = -1;\n  while (++index < children.length) {\n    if (check(children[index])) return true;\n  }\n  return false;\n}\n\n/**\n * @param {unknown} query_\n *   Query-like value.\n * @returns {never}\n *   Nothing.\n * @throws\n *   Exception.\n */\nfunction unknownPseudo(query_) {\n  // Runtime JS guarantees it has a `name`.\n  const query = /** @type {AstPseudoClass} */query_;\n  throw new Error('Unknown pseudo-selector `' + query.name + '`');\n}","map":{"version":3,"names":["extendedFilter","parse","commas","ok","assert","unreachable","hasProperty","whitespace","fauxEsmNthCheck","zwitch","walk","nthCheck","default","pseudo","handlers","anyLink","blank","checked","dir","disabled","empty","enabled","firstChild","firstOfType","has","is","lang","lastChild","lastOfType","not","nthChild","nthLastChild","nthLastOfType","nthOfType","onlyChild","onlyOfType","optional","readOnly","readWrite","required","root","scope","invalid","invalidPseudo","unknown","unknownPseudo","_","element","tagName","assertDeep","state","query","shallow","Error","name","someChildren","check","child","type","Boolean","properties","_1","_2","_3","argument","direction","value","elementIndex","typeIndex","getCachedNthCheck","cachedFunction","_cachedFn","a","b","childState","found","one","results","rootQuery","scopeElements","children","length","language","undefined","elementCount","typeCount","index","parent","editableOrEditingHost","schema","space","includes","query_"],"sources":["/Users/mubarakmuse/Abubakar-Islamic-Institute-LMS/node_modules/hast-util-select/lib/pseudo.js"],"sourcesContent":["/**\n * @import {AstPseudoClass} from 'css-selector-parser'\n * @import {default as NthCheck} from 'nth-check'\n * @import {ElementContent, Element, Parents} from 'hast'\n * @import {State} from './index.js'\n */\n\nimport {extendedFilter} from 'bcp-47-match'\nimport {parse as commas} from 'comma-separated-tokens'\nimport {ok as assert, unreachable} from 'devlop'\nimport {hasProperty} from 'hast-util-has-property'\nimport {whitespace} from 'hast-util-whitespace'\nimport fauxEsmNthCheck from 'nth-check'\nimport {zwitch} from 'zwitch'\nimport {walk} from './walk.js'\n\n/** @type {NthCheck} */\n// @ts-expect-error: types are broken.\nconst nthCheck = fauxEsmNthCheck.default || fauxEsmNthCheck\n\n/** @type {(rule: AstPseudoClass, element: Element, index: number | undefined, parent: Parents | undefined, state: State) => boolean} */\nexport const pseudo = zwitch('name', {\n  handlers: {\n    'any-link': anyLink,\n    blank,\n    checked,\n    dir,\n    disabled,\n    empty,\n    enabled,\n    'first-child': firstChild,\n    'first-of-type': firstOfType,\n    has,\n    is,\n    lang,\n    'last-child': lastChild,\n    'last-of-type': lastOfType,\n    not,\n    'nth-child': nthChild,\n    'nth-last-child': nthLastChild,\n    'nth-last-of-type': nthLastOfType,\n    'nth-of-type': nthOfType,\n    'only-child': onlyChild,\n    'only-of-type': onlyOfType,\n    optional,\n    'read-only': readOnly,\n    'read-write': readWrite,\n    required,\n    root,\n    scope\n  },\n  invalid: invalidPseudo,\n  unknown: unknownPseudo\n})\n\n/**\n * Check whether an element matches an `:any-link` pseudo.\n *\n * @param {AstPseudoClass} _\n *   Query.\n * @param {Element} element\n *   Element.\n * @returns {boolean}\n *   Whether `element` matches `query`.\n */\nfunction anyLink(_, element) {\n  return (\n    (element.tagName === 'a' ||\n      element.tagName === 'area' ||\n      element.tagName === 'link') &&\n    hasProperty(element, 'href')\n  )\n}\n\n/**\n * @param {State} state\n *   State.\n * @param {AstPseudoClass} query\n *   Query.\n */\nfunction assertDeep(state, query) {\n  if (state.shallow) {\n    throw new Error('Cannot use `:' + query.name + '` without parent')\n  }\n}\n\n/**\n * Check whether an element matches a `:blank` pseudo.\n *\n * @param {AstPseudoClass} _\n *   Query.\n * @param {Element} element\n *   Element.\n * @returns {boolean}\n *   Whether `element` matches `query`.\n */\nfunction blank(_, element) {\n  return !someChildren(element, check)\n\n  /**\n   * @param {ElementContent} child\n   * @returns {boolean}\n   */\n  function check(child) {\n    return (\n      child.type === 'element' || (child.type === 'text' && !whitespace(child))\n    )\n  }\n}\n\n/**\n * Check whether an element matches a `:checked` pseudo.\n *\n * @param {AstPseudoClass} _\n *   Query.\n * @param {Element} element\n *   Element.\n * @returns {boolean}\n *   Whether `element` matches `query`.\n */\nfunction checked(_, element) {\n  if (element.tagName === 'input' || element.tagName === 'menuitem') {\n    return Boolean(\n      (element.properties.type === 'checkbox' ||\n        element.properties.type === 'radio') &&\n        hasProperty(element, 'checked')\n    )\n  }\n\n  if (element.tagName === 'option') {\n    return hasProperty(element, 'selected')\n  }\n\n  return false\n}\n\n/**\n * Check whether an element matches a `:dir()` pseudo.\n *\n * @param {AstPseudoClass} query\n *   Query.\n * @param {Element} _1\n *   Element.\n * @param {number | undefined} _2\n *   Index of `element` in `parent`.\n * @param {Parents | undefined} _3\n *   Parent of `element`.\n * @param {State} state\n *   State.\n * @returns {boolean}\n *   Whether `element` matches `query`.\n */\n// eslint-disable-next-line unicorn/prevent-abbreviations\nfunction dir(query, _1, _2, _3, state) {\n  assert(query.argument, 'expected `argument`')\n  assert(query.argument.type === 'String', 'expected plain text')\n  return state.direction === query.argument.value\n}\n\n/**\n * Check whether an element matches a `:disabled` pseudo.\n *\n * @param {AstPseudoClass} _\n *   Query.\n * @param {Element} element\n *   Element.\n * @returns {boolean}\n *   Whether `element` matches `query`.\n */\nfunction disabled(_, element) {\n  return (\n    (element.tagName === 'button' ||\n      element.tagName === 'input' ||\n      element.tagName === 'select' ||\n      element.tagName === 'textarea' ||\n      element.tagName === 'optgroup' ||\n      element.tagName === 'option' ||\n      element.tagName === 'menuitem' ||\n      element.tagName === 'fieldset') &&\n    hasProperty(element, 'disabled')\n  )\n}\n\n/**\n * Check whether an element matches an `:empty` pseudo.\n *\n * @param {AstPseudoClass} _\n *   Query.\n * @param {Element} element\n *   Element.\n * @returns {boolean}\n *   Whether `element` matches `query`.\n */\nfunction empty(_, element) {\n  return !someChildren(element, check)\n\n  /**\n   * @param {ElementContent} child\n   * @returns {boolean}\n   */\n  function check(child) {\n    return child.type === 'element' || child.type === 'text'\n  }\n}\n\n/**\n * Check whether an element matches an `:enabled` pseudo.\n *\n * @param {AstPseudoClass} query\n *   Query.\n * @param {Element} element\n *   Element.\n * @returns {boolean}\n *   Whether `element` matches `query`.\n */\nfunction enabled(query, element) {\n  return !disabled(query, element)\n}\n\n/**\n * Check whether an element matches a `:first-child` pseudo.\n *\n * @param {AstPseudoClass} query\n *   Query.\n * @param {Element} _1\n *   Element.\n * @param {number | undefined} _2\n *   Index of `element` in `parent`.\n * @param {Parents | undefined} _3\n *   Parent of `element`.\n * @param {State} state\n *   State.\n * @returns {boolean}\n *   Whether `element` matches `query`.\n */\nfunction firstChild(query, _1, _2, _3, state) {\n  assertDeep(state, query)\n  return state.elementIndex === 0\n}\n\n/**\n * Check whether an element matches a `:first-of-type` pseudo.\n *\n * @param {AstPseudoClass} query\n *   Query.\n * @param {Element} _1\n *   Element.\n * @param {number | undefined} _2\n *   Index of `element` in `parent`.\n * @param {Parents | undefined} _3\n *   Parent of `element`.\n * @param {State} state\n *   State.\n * @returns {boolean}\n *   Whether `element` matches `query`.\n */\nfunction firstOfType(query, _1, _2, _3, state) {\n  assertDeep(state, query)\n  return state.typeIndex === 0\n}\n\n/**\n * @param {AstPseudoClass} query\n *   Query.\n * @returns {(value: number) => boolean}\n *   N.\n */\nfunction getCachedNthCheck(query) {\n  /** @type {(value: number) => boolean} */\n  // @ts-expect-error: cache.\n  let cachedFunction = query._cachedFn\n\n  if (!cachedFunction) {\n    const value = query.argument\n    assert(value, 'expected `argument`')\n\n    if (value.type !== 'Formula') {\n      throw new Error(\n        'Expected `nth` formula, such as `even` or `2n+1` (`of` is not yet supported)'\n      )\n    }\n\n    cachedFunction = nthCheck(value.a + 'n+' + value.b)\n    // @ts-expect-error: cache.\n    query._cachedFn = cachedFunction\n  }\n\n  return cachedFunction\n}\n\n/**\n * @param {AstPseudoClass} query\n *   Query.\n * @param {Element} element\n *   Element.\n * @param {number | undefined} _1\n *   Index of `element` in `parent`.\n * @param {Parents | undefined} _2\n *   Parent of `element`.\n * @param {State} state\n *   State.\n * @returns {boolean}\n *   Whether `element` matches `query`.\n */\nfunction has(query, element, _1, _2, state) {\n  assert(query.argument, 'expected `argument`')\n  assert(query.argument.type === 'Selector', 'expected selector')\n\n  /** @type {State} */\n  const childState = {\n    ...state,\n    // Not found yet.\n    found: false,\n    // One result is enough.\n    one: true,\n    results: [],\n    rootQuery: query.argument,\n    scopeElements: [element],\n    // Do walk deep.\n    shallow: false\n  }\n\n  walk(childState, {type: 'root', children: element.children})\n\n  return childState.results.length > 0\n}\n\n// Shouldn’t be called, parser gives correct data.\n/* c8 ignore next 3 */\nfunction invalidPseudo() {\n  unreachable('Invalid pseudo-selector')\n}\n\n/**\n * Check whether an element `:is` further selectors.\n *\n * @param {AstPseudoClass} query\n *   Query.\n * @param {Element} element\n *   Element.\n * @param {number | undefined} _1\n *   Index of `element` in `parent`.\n * @param {Parents | undefined} _2\n *   Parent of `element`.\n * @param {State} state\n *   State.\n * @returns {boolean}\n *   Whether `element` matches `query`.\n */\nfunction is(query, element, _1, _2, state) {\n  assert(query.argument, 'expected `argument`')\n  assert(query.argument.type === 'Selector', 'expected selector')\n\n  /** @type {State} */\n  const childState = {\n    ...state,\n    // Not found yet.\n    found: false,\n    // One result is enough.\n    one: true,\n    results: [],\n    rootQuery: query.argument,\n    scopeElements: [element],\n    // Do walk deep.\n    shallow: false\n  }\n\n  walk(childState, element)\n\n  return childState.results[0] === element\n}\n\n/**\n * Check whether an element matches a `:lang()` pseudo.\n *\n * @param {AstPseudoClass} query\n *   Query.\n * @param {Element} _1\n *   Element.\n * @param {number | undefined} _2\n *   Index of `element` in `parent`.\n * @param {Parents | undefined} _3\n *   Parent of `element`.\n * @param {State} state\n *   State.\n * @returns {boolean}\n *   Whether `element` matches `query`.\n */\nfunction lang(query, _1, _2, _3, state) {\n  assert(query.argument, 'expected `argument`')\n  assert(query.argument.type === 'String', 'expected string')\n\n  return (\n    state.language !== '' &&\n    state.language !== undefined &&\n    extendedFilter(state.language, commas(query.argument.value)).length > 0\n  )\n}\n\n/**\n * Check whether an element matches a `:last-child` pseudo.\n *\n * @param {AstPseudoClass} query\n *   Query.\n * @param {Element} _1\n *   Element.\n * @param {number | undefined} _2\n *   Index of `element` in `parent`.\n * @param {Parents | undefined} _3\n *   Parent of `element`.\n * @param {State} state\n *   State.\n * @returns {boolean}\n *   Whether `element` matches `query`.\n */\nfunction lastChild(query, _1, _2, _3, state) {\n  assertDeep(state, query)\n  return Boolean(\n    state.elementCount && state.elementIndex === state.elementCount - 1\n  )\n}\n\n/**\n * Check whether an element matches a `:last-of-type` pseudo.\n *\n * @param {AstPseudoClass} query\n *   Query.\n * @param {Element} _1\n *   Element.\n * @param {number | undefined} _2\n *   Index of `element` in `parent`.\n * @param {Parents | undefined} _3\n *   Parent of `element`.\n * @param {State} state\n *   State.\n * @returns {boolean}\n *   Whether `element` matches `query`.\n */\nfunction lastOfType(query, _1, _2, _3, state) {\n  assertDeep(state, query)\n  return (\n    typeof state.typeIndex === 'number' &&\n    typeof state.typeCount === 'number' &&\n    state.typeIndex === state.typeCount - 1\n  )\n}\n\n/**\n * Check whether an element does `:not` match further selectors.\n *\n * @param {AstPseudoClass} query\n *   Query.\n * @param {Element} element\n *   Element.\n * @param {number | undefined} index\n *   Index of `element` in `parent`.\n * @param {Parents | undefined} parent\n *   Parent of `element`.\n * @param {State} state\n *   State.\n * @returns {boolean}\n *   Whether `element` matches `query`.\n */\nfunction not(query, element, index, parent, state) {\n  return !is(query, element, index, parent, state)\n}\n\n/**\n * Check whether an element matches an `:nth-child` pseudo.\n *\n * @param {AstPseudoClass} query\n *   Query.\n * @param {Element} _1\n *   Element.\n * @param {number | undefined} _2\n *   Index of `element` in `parent`.\n * @param {Parents | undefined} _3\n *   Parent of `element`.\n * @param {State} state\n *   State.\n * @returns {boolean}\n *   Whether `element` matches `query`.\n */\nfunction nthChild(query, _1, _2, _3, state) {\n  const cachedFunction = getCachedNthCheck(query)\n  assertDeep(state, query)\n  return (\n    typeof state.elementIndex === 'number' && cachedFunction(state.elementIndex)\n  )\n}\n\n/**\n * Check whether an element matches an `:nth-last-child` pseudo.\n *\n * @param {AstPseudoClass} query\n *   Query.\n * @param {Element} _1\n *   Element.\n * @param {number | undefined} _2\n *   Index of `element` in `parent`.\n * @param {Parents | undefined} _3\n *   Parent of `element`.\n * @param {State} state\n *   State.\n * @returns {boolean}\n *   Whether `element` matches `query`.\n */\nfunction nthLastChild(query, _1, _2, _3, state) {\n  const cachedFunction = getCachedNthCheck(query)\n  assertDeep(state, query)\n  return Boolean(\n    typeof state.elementCount === 'number' &&\n      typeof state.elementIndex === 'number' &&\n      cachedFunction(state.elementCount - state.elementIndex - 1)\n  )\n}\n\n/**\n * Check whether an element matches a `:nth-last-of-type` pseudo.\n *\n * @param {AstPseudoClass} query\n *   Query.\n * @param {Element} _1\n *   Element.\n * @param {number | undefined} _2\n *   Index of `element` in `parent`.\n * @param {Parents | undefined} _3\n *   Parent of `element`.\n * @param {State} state\n *   State.\n * @returns {boolean}\n *   Whether `element` matches `query`.\n */\nfunction nthLastOfType(query, _1, _2, _3, state) {\n  const cachedFunction = getCachedNthCheck(query)\n  assertDeep(state, query)\n  return (\n    typeof state.typeCount === 'number' &&\n    typeof state.typeIndex === 'number' &&\n    cachedFunction(state.typeCount - 1 - state.typeIndex)\n  )\n}\n\n/**\n * Check whether an element matches an `:nth-of-type` pseudo.\n *\n * @param {AstPseudoClass} query\n *   Query.\n * @param {Element} _1\n *   Element.\n * @param {number | undefined} _2\n *   Index of `element` in `parent`.\n * @param {Parents | undefined} _3\n *   Parent of `element`.\n * @param {State} state\n *   State.\n * @returns {boolean}\n *   Whether `element` matches `query`.\n */\nfunction nthOfType(query, _1, _2, _3, state) {\n  const cachedFunction = getCachedNthCheck(query)\n  assertDeep(state, query)\n  return typeof state.typeIndex === 'number' && cachedFunction(state.typeIndex)\n}\n\n/**\n * Check whether an element matches an `:only-child` pseudo.\n *\n * @param {AstPseudoClass} query\n *   Query.\n * @param {Element} _1\n *   Element.\n * @param {number | undefined} _2\n *   Index of `element` in `parent`.\n * @param {Parents | undefined} _3\n *   Parent of `element`.\n * @param {State} state\n *   State.\n * @returns {boolean}\n *   Whether `element` matches `query`.\n */\nfunction onlyChild(query, _1, _2, _3, state) {\n  assertDeep(state, query)\n  return state.elementCount === 1\n}\n\n/**\n * Check whether an element matches an `:only-of-type` pseudo.\n *\n * @param {AstPseudoClass} query\n *   Query.\n * @param {Element} _1\n *   Element.\n * @param {number | undefined} _2\n *   Index of `element` in `parent`.\n * @param {Parents | undefined} _3\n *   Parent of `element`.\n * @param {State} state\n *   State.\n * @returns {boolean}\n *   Whether `element` matches `query`.\n */\nfunction onlyOfType(query, _1, _2, _3, state) {\n  assertDeep(state, query)\n  return state.typeCount === 1\n}\n\n/**\n * Check whether an element matches an `:optional` pseudo.\n *\n * @param {AstPseudoClass} query\n *   Query.\n * @param {Element} element\n *   Element.\n * @returns {boolean}\n *   Whether `element` matches `query`.\n */\nfunction optional(query, element) {\n  return !required(query, element)\n}\n\n/**\n * Check whether an element matches a `:read-only` pseudo.\n *\n * @param {AstPseudoClass} query\n *   Query.\n * @param {Element} element\n *   Element.\n * @param {number | undefined} index\n *   Index of `element` in `parent`.\n * @param {Parents | undefined} parent\n *   Parent of `element`.\n * @param {State} state\n *   State.\n * @returns {boolean}\n *   Whether `element` matches `query`.\n */\nfunction readOnly(query, element, index, parent, state) {\n  return !readWrite(query, element, index, parent, state)\n}\n\n/**\n * Check whether an element matches a `:read-write` pseudo.\n *\n * @param {AstPseudoClass} _\n *   Query.\n * @param {Element} element\n *   Element.\n * @param {number | undefined} _1\n *   Index of `element` in `parent`.\n * @param {Parents | undefined} _2\n *   Parent of `element`.\n * @param {State} state\n *   State.\n * @returns {boolean}\n *   Whether `element` matches `query`.\n */\nfunction readWrite(_, element, _1, _2, state) {\n  return element.tagName === 'input' || element.tagName === 'textarea'\n    ? !hasProperty(element, 'readOnly') && !hasProperty(element, 'disabled')\n    : Boolean(state.editableOrEditingHost)\n}\n\n/**\n * Check whether an element matches a `:required` pseudo.\n *\n * @param {AstPseudoClass} _\n *   Query.\n * @param {Element} element\n *   Element.\n * @returns {boolean}\n *   Whether `element` matches `query`.\n */\nfunction required(_, element) {\n  return (\n    (element.tagName === 'input' ||\n      element.tagName === 'textarea' ||\n      element.tagName === 'select') &&\n    hasProperty(element, 'required')\n  )\n}\n\n/**\n * Check whether an element matches a `:root` pseudo.\n *\n * @param {AstPseudoClass} _1\n *   Query.\n * @param {Element} element\n *   Element.\n * @param {number | undefined} _2\n *   Index of `element` in `parent`.\n * @param {Parents | undefined} parent\n *   Parent of `element`.\n * @param {State} state\n *   State.\n * @returns {boolean}\n *   Whether `element` matches `query`.\n */\nfunction root(_1, element, _2, parent, state) {\n  return Boolean(\n    (!parent || parent.type === 'root') &&\n      state.schema &&\n      (state.schema.space === 'html' || state.schema.space === 'svg') &&\n      (element.tagName === 'html' || element.tagName === 'svg')\n  )\n}\n\n/**\n * Check whether an element matches a `:scope` pseudo.\n *\n * @param {AstPseudoClass} _1\n *   Query.\n * @param {Element} element\n *   Element.\n * @param {number | undefined} _2\n *   Index of `element` in `parent`.\n * @param {Parents | undefined} _3\n *   Parent of `element`.\n * @param {State} state\n *   State.\n * @returns {boolean}\n *   Whether `element` matches `query`.\n */\nfunction scope(_1, element, _2, _3, state) {\n  return state.scopeElements.includes(element)\n}\n\n/**\n * Check children.\n *\n * @param {Element} element\n *   Element.\n * @param {(child: ElementContent) => boolean} check\n *   Check.\n * @returns {boolean}\n *   Whether a child of `element` matches `check`.\n */\nfunction someChildren(element, check) {\n  const children = element.children\n  let index = -1\n\n  while (++index < children.length) {\n    if (check(children[index])) return true\n  }\n\n  return false\n}\n\n/**\n * @param {unknown} query_\n *   Query-like value.\n * @returns {never}\n *   Nothing.\n * @throws\n *   Exception.\n */\nfunction unknownPseudo(query_) {\n  // Runtime JS guarantees it has a `name`.\n  const query = /** @type {AstPseudoClass} */ (query_)\n  throw new Error('Unknown pseudo-selector `' + query.name + '`')\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}