{"ast":null,"code":"/**\n * The MIT License\n * Copyright (c) 2018 Dmitriy Kubyshkin\n * Copied from https://github.com/grassator/insert-text-at-cursor\n */\n\nvar browserSupportsTextareaTextNodes;\n\n/**\n * @param {HTMLElement} input\n * @return {boolean}\n */\nfunction canManipulateViaTextNodes(input) {\n  if (input.nodeName !== 'TEXTAREA') {\n    return false;\n  }\n  if (typeof browserSupportsTextareaTextNodes === 'undefined') {\n    var textarea = document.createElement('textarea');\n    textarea.value = '1';\n    browserSupportsTextareaTextNodes = !!textarea.firstChild;\n  }\n  return browserSupportsTextareaTextNodes;\n}\n\n/**\n * @param {HTMLTextAreaElement|HTMLInputElement} input\n * @param {string} text\n * @returns {void}\n */\nexport function insertTextAtPosition(input, text) {\n  // Most of the used APIs only work with the field selected\n  input.focus();\n\n  // IE 8-10\n  if (document.selection) {\n    var ieRange = document.selection.createRange();\n    ieRange.text = text;\n\n    // Move cursor after the inserted text\n    ieRange.collapse(false /* to the end */);\n    ieRange.select();\n    return;\n  }\n\n  // Webkit + Edge\n  var isSuccess = false;\n  if (text !== '') {\n    isSuccess = document.execCommand && document.execCommand('insertText', false, text);\n  } else {\n    isSuccess = document.execCommand && document.execCommand('delete', false);\n  }\n  if (!isSuccess) {\n    var start = input.selectionStart;\n    var end = input.selectionEnd;\n    // Firefox (non-standard method)\n    if (typeof input.setRangeText === 'function') {\n      input.setRangeText(text);\n    } else {\n      // To make a change we just need a Range, not a Selection\n      var range = document.createRange();\n      var textNode = document.createTextNode(text);\n      if (canManipulateViaTextNodes(input)) {\n        var node = input.firstChild;\n\n        // If textarea is empty, just insert the text\n        if (!node) {\n          input.appendChild(textNode);\n        } else {\n          // Otherwise we need to find a nodes for start and end\n          var offset = 0;\n          var startNode = null;\n          var endNode = null;\n          while (node && (startNode === null || endNode === null)) {\n            var nodeLength = node.nodeValue.length;\n\n            // if start of the selection falls into current node\n            if (start >= offset && start <= offset + nodeLength) {\n              range.setStart(startNode = node, start - offset);\n            }\n\n            // if end of the selection falls into current node\n            if (end >= offset && end <= offset + nodeLength) {\n              range.setEnd(endNode = node, end - offset);\n            }\n            offset += nodeLength;\n            node = node.nextSibling;\n          }\n\n          // If there is some text selected, remove it as we should replace it\n          if (start !== end) {\n            range.deleteContents();\n          }\n        }\n      }\n\n      // If the node is a textarea and the range doesn't span outside the element\n      //\n      // Get the commonAncestorContainer of the selected range and test its type\n      // If the node is of type `#text` it means that we're still working with text nodes within our textarea element\n      // otherwise, if it's of type `#document` for example it means our selection spans outside the textarea.\n      if (canManipulateViaTextNodes(input) && range.commonAncestorContainer.nodeName === '#text') {\n        // Finally insert a new node. The browser will automatically split start and end nodes into two if necessary\n        range.insertNode(textNode);\n      } else {\n        // If the node is not a textarea or the range spans outside a textarea the only way is to replace the whole value\n        var value = input.value;\n        input.value = value.slice(0, start) + text + value.slice(end);\n      }\n    }\n\n    // Correct the cursor position to be at the end of the insertion\n    input.setSelectionRange(start + text.length, start + text.length);\n\n    // Notify any possible listeners of the change\n    var e = document.createEvent('UIEvent');\n    e.initEvent('input', true, false);\n    input.dispatchEvent(e);\n  }\n}","map":{"version":3,"names":["browserSupportsTextareaTextNodes","canManipulateViaTextNodes","input","nodeName","textarea","document","createElement","value","firstChild","insertTextAtPosition","text","focus","selection","ieRange","createRange","collapse","select","isSuccess","execCommand","start","selectionStart","end","selectionEnd","setRangeText","range","textNode","createTextNode","node","appendChild","offset","startNode","endNode","nodeLength","nodeValue","length","setStart","setEnd","nextSibling","deleteContents","commonAncestorContainer","insertNode","slice","setSelectionRange","e","createEvent","initEvent","dispatchEvent"],"sources":["/Users/mubarakmuse/Abubakar-Islamic-Institute-LMS/node_modules/@uiw/react-md-editor/esm/utils/InsertTextAtPosition.js"],"sourcesContent":["/**\n * The MIT License\n * Copyright (c) 2018 Dmitriy Kubyshkin\n * Copied from https://github.com/grassator/insert-text-at-cursor\n */\n\nvar browserSupportsTextareaTextNodes;\n\n/**\n * @param {HTMLElement} input\n * @return {boolean}\n */\nfunction canManipulateViaTextNodes(input) {\n  if (input.nodeName !== 'TEXTAREA') {\n    return false;\n  }\n  if (typeof browserSupportsTextareaTextNodes === 'undefined') {\n    var textarea = document.createElement('textarea');\n    textarea.value = '1';\n    browserSupportsTextareaTextNodes = !!textarea.firstChild;\n  }\n  return browserSupportsTextareaTextNodes;\n}\n\n/**\n * @param {HTMLTextAreaElement|HTMLInputElement} input\n * @param {string} text\n * @returns {void}\n */\nexport function insertTextAtPosition(input, text) {\n  // Most of the used APIs only work with the field selected\n  input.focus();\n\n  // IE 8-10\n  if (document.selection) {\n    var ieRange = document.selection.createRange();\n    ieRange.text = text;\n\n    // Move cursor after the inserted text\n    ieRange.collapse(false /* to the end */);\n    ieRange.select();\n    return;\n  }\n\n  // Webkit + Edge\n  var isSuccess = false;\n  if (text !== '') {\n    isSuccess = document.execCommand && document.execCommand('insertText', false, text);\n  } else {\n    isSuccess = document.execCommand && document.execCommand('delete', false);\n  }\n  if (!isSuccess) {\n    var start = input.selectionStart;\n    var end = input.selectionEnd;\n    // Firefox (non-standard method)\n    if (typeof input.setRangeText === 'function') {\n      input.setRangeText(text);\n    } else {\n      // To make a change we just need a Range, not a Selection\n      var range = document.createRange();\n      var textNode = document.createTextNode(text);\n      if (canManipulateViaTextNodes(input)) {\n        var node = input.firstChild;\n\n        // If textarea is empty, just insert the text\n        if (!node) {\n          input.appendChild(textNode);\n        } else {\n          // Otherwise we need to find a nodes for start and end\n          var offset = 0;\n          var startNode = null;\n          var endNode = null;\n          while (node && (startNode === null || endNode === null)) {\n            var nodeLength = node.nodeValue.length;\n\n            // if start of the selection falls into current node\n            if (start >= offset && start <= offset + nodeLength) {\n              range.setStart(startNode = node, start - offset);\n            }\n\n            // if end of the selection falls into current node\n            if (end >= offset && end <= offset + nodeLength) {\n              range.setEnd(endNode = node, end - offset);\n            }\n            offset += nodeLength;\n            node = node.nextSibling;\n          }\n\n          // If there is some text selected, remove it as we should replace it\n          if (start !== end) {\n            range.deleteContents();\n          }\n        }\n      }\n\n      // If the node is a textarea and the range doesn't span outside the element\n      //\n      // Get the commonAncestorContainer of the selected range and test its type\n      // If the node is of type `#text` it means that we're still working with text nodes within our textarea element\n      // otherwise, if it's of type `#document` for example it means our selection spans outside the textarea.\n      if (canManipulateViaTextNodes(input) && range.commonAncestorContainer.nodeName === '#text') {\n        // Finally insert a new node. The browser will automatically split start and end nodes into two if necessary\n        range.insertNode(textNode);\n      } else {\n        // If the node is not a textarea or the range spans outside a textarea the only way is to replace the whole value\n        var value = input.value;\n        input.value = value.slice(0, start) + text + value.slice(end);\n      }\n    }\n\n    // Correct the cursor position to be at the end of the insertion\n    input.setSelectionRange(start + text.length, start + text.length);\n\n    // Notify any possible listeners of the change\n    var e = document.createEvent('UIEvent');\n    e.initEvent('input', true, false);\n    input.dispatchEvent(e);\n  }\n}"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}