{"ast":null,"code":"/**\n * @import {Element, Root, Text} from 'hast'\n * @import {Grammar, Languages} from 'prismjs'\n */\n\n/**\n * @typedef _Token\n *   Hidden Prism token.\n * @property {string} alias\n *   Alias.\n * @property {string} content\n *   Content.\n * @property {number} length\n *   Length.\n * @property {string} type\n *   Type.\n */\n\n/**\n * @typedef _Env\n *   Hidden Prism environment.\n * @property {Record<string, string>} attributes\n *   Attributes.\n * @property {Array<string>} classes\n *   Classes.\n * @property {Array<RefractorElement | Text> | RefractorElement | Text} content\n *   Content.\n * @property {string} language\n *   Language.\n * @property {string} tag\n *   Tag.\n * @property {string} type\n *   Type.\n */\n\n/**\n * @typedef {Omit<Element, 'children'> & {children: Array<RefractorElement | Text>}} RefractorElement\n *   Element; narrowed down to what’s used here.\n */\n\n/**\n * @typedef {Omit<Root, 'children'> & {children: Array<RefractorElement | Text>}} RefractorRoot\n *   Root; narrowed down to what’s used here.\n */\n\n/**\n * @typedef {((prism: Refractor) => undefined | void) & {aliases?: Array<string> | undefined, displayName: string}} Syntax\n *   Refractor syntax function.\n */\n\n/**\n * @typedef Refractor\n *   Virtual syntax highlighting\n * @property {typeof alias} alias\n * @property {Languages} languages\n * @property {typeof listLanguages} listLanguages\n * @property {typeof highlight} highlight\n * @property {typeof registered} registered\n * @property {typeof register} register\n */\n\n// Load all stuff in `prism.js` itself, except for `prism-file-highlight.js`.\n// The wrapped non-leaky grammars are loaded instead of Prism’s originals.\nimport { h } from 'hastscript';\nimport { parseEntities } from 'parse-entities';\nimport { Prism } from './prism-core.js';\n\n// To do: next major, use `Object.hasOwn`.\nconst own = {}.hasOwnProperty;\n\n// Inherit.\nfunction Refractor() {}\nRefractor.prototype = Prism;\n\n/** @type {Refractor} */\n// @ts-expect-error: TS is wrong.\nexport const refractor = new Refractor();\n\n// Create.\nrefractor.highlight = highlight;\nrefractor.register = register;\nrefractor.alias = alias;\nrefractor.registered = registered;\nrefractor.listLanguages = listLanguages;\n\n// @ts-expect-error Overwrite Prism.\nrefractor.util.encode = encode;\n// @ts-expect-error Overwrite Prism.\nrefractor.Token.stringify = stringify;\n\n/**\n * Highlight `value` (code) as `language` (programming language).\n *\n * @param {string} value\n *   Code to highlight.\n * @param {Grammar | string} language\n *   Programming language name, alias, or grammar.\n * @returns {RefractorRoot}\n *   Node representing highlighted code.\n */\nfunction highlight(value, language) {\n  if (typeof value !== 'string') {\n    throw new TypeError('Expected `string` for `value`, got `' + value + '`');\n  }\n\n  /** @type {Grammar} */\n  let grammar;\n  /** @type {string | undefined} */\n  let name;\n\n  // `name` is a grammar object.\n  // This was called internally by Prism.js before 1.28.0.\n  /* c8 ignore next 2 */\n  if (language && typeof language === 'object') {\n    grammar = language;\n  } else {\n    name = language;\n    if (typeof name !== 'string') {\n      throw new TypeError('Expected `string` for `name`, got `' + name + '`');\n    }\n    if (own.call(refractor.languages, name)) {\n      grammar = refractor.languages[name];\n    } else {\n      throw new Error('Unknown language: `' + name + '` is not registered');\n    }\n  }\n  return {\n    type: 'root',\n    // @ts-expect-error: we hacked Prism to accept and return the things we want.\n    children: Prism.highlight.call(refractor, value, grammar, name)\n  };\n}\n\n/**\n * Register a syntax.\n *\n * @param {Syntax} syntax\n *   Language function made for refractor, as in, the files in\n *   `refractor/lang/*.js`.\n * @returns {undefined}\n *   Nothing.\n */\nfunction register(syntax) {\n  if (typeof syntax !== 'function' || !syntax.displayName) {\n    throw new Error('Expected `function` for `syntax`, got `' + syntax + '`');\n  }\n\n  // Do not duplicate registrations.\n  if (!own.call(refractor.languages, syntax.displayName)) {\n    syntax(refractor);\n  }\n}\n\n/**\n * Register aliases for already registered languages.\n *\n * @param {Record<string, ReadonlyArray<string> | string> | string} language\n *   Language to alias.\n * @param {ReadonlyArray<string> | string | null | undefined} [alias]\n *   Aliases.\n * @returns {undefined}\n *   Nothing.\n */\nfunction alias(language, alias) {\n  const languages = refractor.languages;\n  /** @type {Record<string, ReadonlyArray<string> | string>} */\n  let map = {};\n  if (typeof language === 'string') {\n    if (alias) {\n      map[language] = alias;\n    }\n  } else {\n    map = language;\n  }\n\n  /** @type {string} */\n  let key;\n  for (key in map) {\n    if (own.call(map, key)) {\n      const value = map[key];\n      const list = typeof value === 'string' ? [value] : value;\n      let index = -1;\n      while (++index < list.length) {\n        languages[list[index]] = languages[key];\n      }\n    }\n  }\n}\n\n/**\n * Check whether an `alias` or `language` is registered.\n *\n * @param {string} aliasOrLanguage\n *   Language or alias to check.\n * @returns {boolean}\n *   Whether the language is registered.\n */\nfunction registered(aliasOrLanguage) {\n  if (typeof aliasOrLanguage !== 'string') {\n    throw new TypeError('Expected `string` for `aliasOrLanguage`, got `' + aliasOrLanguage + '`');\n  }\n  return own.call(refractor.languages, aliasOrLanguage);\n}\n\n/**\n * List all registered languages (names and aliases).\n *\n * @returns {Array<string>}\n *   List of language names.\n */\nfunction listLanguages() {\n  const languages = refractor.languages;\n  /** @type {Array<string>} */\n  const list = [];\n  /** @type {string} */\n  let language;\n  for (language in languages) {\n    if (own.call(languages, language) && typeof languages[language] === 'object') {\n      list.push(language);\n    }\n  }\n  return list;\n}\n\n/**\n * @param {Array<_Token | string> | _Token | string} value\n *   Token to stringify.\n * @param {string} language\n *   Language of the token.\n * @returns {Array<RefractorElement | Text> | RefractorElement | Text}\n *   Node representing the token.\n */\nfunction stringify(value, language) {\n  if (typeof value === 'string') {\n    return {\n      type: 'text',\n      value\n    };\n  }\n  if (Array.isArray(value)) {\n    /** @type {Array<RefractorElement | Text>} */\n    const result = [];\n    let index = -1;\n    while (++index < value.length) {\n      if (value[index] !== null && value[index] !== undefined && value[index] !== '') {\n        // @ts-expect-error Assume no sub-arrays.\n        result.push(stringify(value[index], language));\n      }\n    }\n    return result;\n  }\n\n  /** @type {_Env} */\n  const env = {\n    attributes: {},\n    classes: ['token', value.type],\n    content: stringify(value.content, language),\n    language,\n    tag: 'span',\n    type: value.type\n  };\n  if (value.alias) {\n    env.classes.push(...(typeof value.alias === 'string' ? [value.alias] : value.alias));\n  }\n\n  // @ts-expect-error Prism.\n  refractor.hooks.run('wrap', env);\n\n  // @ts-expect-error Hush, it’s fine.\n  return h(env.tag + '.' + env.classes.join('.'), attributes(env.attributes), env.content);\n}\n\n/**\n * @template {unknown} T\n *   Tokens.\n * @param {T} tokens\n *   Input.\n * @returns {T}\n *   Output, same as input.\n */\nfunction encode(tokens) {\n  return tokens;\n}\n\n/**\n * @param {Record<string, string>} record\n *   Attributes.\n * @returns {Record<string, string>}\n *   Attributes.\n */\nfunction attributes(record) {\n  /** @type {string} */\n  let key;\n  for (key in record) {\n    if (own.call(record, key)) {\n      record[key] = parseEntities(record[key]);\n    }\n  }\n  return record;\n}","map":{"version":3,"names":["h","parseEntities","Prism","own","hasOwnProperty","Refractor","prototype","refractor","highlight","register","alias","registered","listLanguages","util","encode","Token","stringify","value","language","TypeError","grammar","name","call","languages","Error","type","children","syntax","displayName","map","key","list","index","length","aliasOrLanguage","push","Array","isArray","result","undefined","env","attributes","classes","content","tag","hooks","run","join","tokens","record"],"sources":["/Users/mubarakmuse/Abubakar-Islamic-Institute-LMS/node_modules/refractor/lib/core.js"],"sourcesContent":["/**\n * @import {Element, Root, Text} from 'hast'\n * @import {Grammar, Languages} from 'prismjs'\n */\n\n/**\n * @typedef _Token\n *   Hidden Prism token.\n * @property {string} alias\n *   Alias.\n * @property {string} content\n *   Content.\n * @property {number} length\n *   Length.\n * @property {string} type\n *   Type.\n */\n\n/**\n * @typedef _Env\n *   Hidden Prism environment.\n * @property {Record<string, string>} attributes\n *   Attributes.\n * @property {Array<string>} classes\n *   Classes.\n * @property {Array<RefractorElement | Text> | RefractorElement | Text} content\n *   Content.\n * @property {string} language\n *   Language.\n * @property {string} tag\n *   Tag.\n * @property {string} type\n *   Type.\n */\n\n/**\n * @typedef {Omit<Element, 'children'> & {children: Array<RefractorElement | Text>}} RefractorElement\n *   Element; narrowed down to what’s used here.\n */\n\n/**\n * @typedef {Omit<Root, 'children'> & {children: Array<RefractorElement | Text>}} RefractorRoot\n *   Root; narrowed down to what’s used here.\n */\n\n/**\n * @typedef {((prism: Refractor) => undefined | void) & {aliases?: Array<string> | undefined, displayName: string}} Syntax\n *   Refractor syntax function.\n */\n\n/**\n * @typedef Refractor\n *   Virtual syntax highlighting\n * @property {typeof alias} alias\n * @property {Languages} languages\n * @property {typeof listLanguages} listLanguages\n * @property {typeof highlight} highlight\n * @property {typeof registered} registered\n * @property {typeof register} register\n */\n\n// Load all stuff in `prism.js` itself, except for `prism-file-highlight.js`.\n// The wrapped non-leaky grammars are loaded instead of Prism’s originals.\nimport {h} from 'hastscript'\nimport {parseEntities} from 'parse-entities'\nimport {Prism} from './prism-core.js'\n\n// To do: next major, use `Object.hasOwn`.\nconst own = {}.hasOwnProperty\n\n// Inherit.\nfunction Refractor() {}\n\nRefractor.prototype = Prism\n\n/** @type {Refractor} */\n// @ts-expect-error: TS is wrong.\nexport const refractor = new Refractor()\n\n// Create.\nrefractor.highlight = highlight\nrefractor.register = register\nrefractor.alias = alias\nrefractor.registered = registered\nrefractor.listLanguages = listLanguages\n\n// @ts-expect-error Overwrite Prism.\nrefractor.util.encode = encode\n// @ts-expect-error Overwrite Prism.\nrefractor.Token.stringify = stringify\n\n/**\n * Highlight `value` (code) as `language` (programming language).\n *\n * @param {string} value\n *   Code to highlight.\n * @param {Grammar | string} language\n *   Programming language name, alias, or grammar.\n * @returns {RefractorRoot}\n *   Node representing highlighted code.\n */\nfunction highlight(value, language) {\n  if (typeof value !== 'string') {\n    throw new TypeError('Expected `string` for `value`, got `' + value + '`')\n  }\n\n  /** @type {Grammar} */\n  let grammar\n  /** @type {string | undefined} */\n  let name\n\n  // `name` is a grammar object.\n  // This was called internally by Prism.js before 1.28.0.\n  /* c8 ignore next 2 */\n  if (language && typeof language === 'object') {\n    grammar = language\n  } else {\n    name = language\n\n    if (typeof name !== 'string') {\n      throw new TypeError('Expected `string` for `name`, got `' + name + '`')\n    }\n\n    if (own.call(refractor.languages, name)) {\n      grammar = refractor.languages[name]\n    } else {\n      throw new Error('Unknown language: `' + name + '` is not registered')\n    }\n  }\n\n  return {\n    type: 'root',\n    // @ts-expect-error: we hacked Prism to accept and return the things we want.\n    children: Prism.highlight.call(refractor, value, grammar, name)\n  }\n}\n\n/**\n * Register a syntax.\n *\n * @param {Syntax} syntax\n *   Language function made for refractor, as in, the files in\n *   `refractor/lang/*.js`.\n * @returns {undefined}\n *   Nothing.\n */\nfunction register(syntax) {\n  if (typeof syntax !== 'function' || !syntax.displayName) {\n    throw new Error('Expected `function` for `syntax`, got `' + syntax + '`')\n  }\n\n  // Do not duplicate registrations.\n  if (!own.call(refractor.languages, syntax.displayName)) {\n    syntax(refractor)\n  }\n}\n\n/**\n * Register aliases for already registered languages.\n *\n * @param {Record<string, ReadonlyArray<string> | string> | string} language\n *   Language to alias.\n * @param {ReadonlyArray<string> | string | null | undefined} [alias]\n *   Aliases.\n * @returns {undefined}\n *   Nothing.\n */\nfunction alias(language, alias) {\n  const languages = refractor.languages\n  /** @type {Record<string, ReadonlyArray<string> | string>} */\n  let map = {}\n\n  if (typeof language === 'string') {\n    if (alias) {\n      map[language] = alias\n    }\n  } else {\n    map = language\n  }\n\n  /** @type {string} */\n  let key\n\n  for (key in map) {\n    if (own.call(map, key)) {\n      const value = map[key]\n      const list = typeof value === 'string' ? [value] : value\n      let index = -1\n\n      while (++index < list.length) {\n        languages[list[index]] = languages[key]\n      }\n    }\n  }\n}\n\n/**\n * Check whether an `alias` or `language` is registered.\n *\n * @param {string} aliasOrLanguage\n *   Language or alias to check.\n * @returns {boolean}\n *   Whether the language is registered.\n */\nfunction registered(aliasOrLanguage) {\n  if (typeof aliasOrLanguage !== 'string') {\n    throw new TypeError(\n      'Expected `string` for `aliasOrLanguage`, got `' + aliasOrLanguage + '`'\n    )\n  }\n\n  return own.call(refractor.languages, aliasOrLanguage)\n}\n\n/**\n * List all registered languages (names and aliases).\n *\n * @returns {Array<string>}\n *   List of language names.\n */\nfunction listLanguages() {\n  const languages = refractor.languages\n  /** @type {Array<string>} */\n  const list = []\n  /** @type {string} */\n  let language\n\n  for (language in languages) {\n    if (\n      own.call(languages, language) &&\n      typeof languages[language] === 'object'\n    ) {\n      list.push(language)\n    }\n  }\n\n  return list\n}\n\n/**\n * @param {Array<_Token | string> | _Token | string} value\n *   Token to stringify.\n * @param {string} language\n *   Language of the token.\n * @returns {Array<RefractorElement | Text> | RefractorElement | Text}\n *   Node representing the token.\n */\nfunction stringify(value, language) {\n  if (typeof value === 'string') {\n    return {type: 'text', value}\n  }\n\n  if (Array.isArray(value)) {\n    /** @type {Array<RefractorElement | Text>} */\n    const result = []\n    let index = -1\n\n    while (++index < value.length) {\n      if (\n        value[index] !== null &&\n        value[index] !== undefined &&\n        value[index] !== ''\n      ) {\n        // @ts-expect-error Assume no sub-arrays.\n        result.push(stringify(value[index], language))\n      }\n    }\n\n    return result\n  }\n\n  /** @type {_Env} */\n  const env = {\n    attributes: {},\n    classes: ['token', value.type],\n    content: stringify(value.content, language),\n    language,\n    tag: 'span',\n    type: value.type\n  }\n\n  if (value.alias) {\n    env.classes.push(\n      ...(typeof value.alias === 'string' ? [value.alias] : value.alias)\n    )\n  }\n\n  // @ts-expect-error Prism.\n  refractor.hooks.run('wrap', env)\n\n  // @ts-expect-error Hush, it’s fine.\n  return h(\n    env.tag + '.' + env.classes.join('.'),\n    attributes(env.attributes),\n    env.content\n  )\n}\n\n/**\n * @template {unknown} T\n *   Tokens.\n * @param {T} tokens\n *   Input.\n * @returns {T}\n *   Output, same as input.\n */\nfunction encode(tokens) {\n  return tokens\n}\n\n/**\n * @param {Record<string, string>} record\n *   Attributes.\n * @returns {Record<string, string>}\n *   Attributes.\n */\nfunction attributes(record) {\n  /** @type {string} */\n  let key\n\n  for (key in record) {\n    if (own.call(record, key)) {\n      record[key] = parseEntities(record[key])\n    }\n  }\n\n  return record\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}