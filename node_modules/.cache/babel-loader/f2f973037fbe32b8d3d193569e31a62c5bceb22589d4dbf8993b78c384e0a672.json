{"ast":null,"code":"/**\n * @import {AstRule} from 'css-selector-parser'\n * @import {Element, Nodes, Parents} from 'hast'\n * @import {State} from './index.js'\n */\n\n/**\n * @typedef Counts\n *   Info on elements in a parent.\n * @property {number} count\n *   Number of elements.\n * @property {Map<string, number>} types\n *   Number of elements by tag name.\n *\n * @typedef Nest\n *   Rule sets by nesting.\n * @property {Array<AstRule> | undefined} adjacentSibling\n *   `a + b`\n * @property {Array<AstRule> | undefined} descendant\n *   `a b`\n * @property {Array<AstRule> | undefined} directChild\n *   `a > b`\n * @property {Array<AstRule> | undefined} generalSibling\n *   `a ~ b`\n */\n\nimport { enterState } from './enter-state.js';\nimport { test } from './test.js';\n\n/** @type {Array<never>} */\nconst empty = [];\n\n/**\n * Walk a tree.\n *\n * @param {State} state\n *   State.\n * @param {Nodes | undefined} tree\n *   Tree.\n */\nexport function walk(state, tree) {\n  if (tree) {\n    one(state, [], tree, undefined, undefined, tree);\n  }\n}\n\n/**\n * Add a rule to a nesting map.\n *\n * @param {Nest} nest\n *   Nesting.\n * @param {keyof Nest} field\n *   Field.\n * @param {AstRule} rule\n *   Rule.\n */\nfunction add(nest, field, rule) {\n  const list = nest[field];\n  if (list) {\n    list.push(rule);\n  } else {\n    nest[field] = [rule];\n  }\n}\n\n/**\n * Check in a parent.\n *\n * @param {State} state\n *   State.\n * @param {Nest} nest\n *   Nesting.\n * @param {Parents} node\n *   Parent.\n * @param {Nodes} tree\n *   Tree.\n * @returns {undefined}\n *   Nothing.\n */\nfunction all(state, nest, node, tree) {\n  const fromParent = combine(nest.descendant, nest.directChild);\n  /** @type {Array<AstRule> | undefined} */\n  let fromSibling;\n  let index = -1;\n  /**\n   * Total counts.\n   * @type {Counts}\n   */\n  const total = {\n    count: 0,\n    types: new Map()\n  };\n  /**\n   * Counts of previous siblings.\n   * @type {Counts}\n   */\n  const before = {\n    count: 0,\n    types: new Map()\n  };\n  while (++index < node.children.length) {\n    count(total, node.children[index]);\n  }\n  index = -1;\n  while (++index < node.children.length) {\n    const child = node.children[index];\n    // Uppercase to prevent prototype polution, injecting `constructor` or so.\n    // Normalize because HTML is insensitive.\n    const name = child.type === 'element' ? child.tagName.toUpperCase() : undefined;\n    // Before counting further elements:\n    state.elementIndex = before.count;\n    state.typeIndex = name ? before.types.get(name) || 0 : 0;\n    // After counting all elements.\n    state.elementCount = total.count;\n    state.typeCount = name ? total.types.get(name) : 0;\n\n    // Only apply if this is a parent, this should be an element, but we check\n    // for parents so that we delve into custom nodes too.\n    if ('children' in child) {\n      const forSibling = combine(fromParent, fromSibling);\n      const nest = one(state, forSibling, node.children[index], index, node, tree);\n      fromSibling = combine(nest.generalSibling, nest.adjacentSibling);\n    }\n\n    // We found one thing, and one is enough.\n    if (state.one && state.found) {\n      break;\n    }\n    count(before, node.children[index]);\n  }\n}\n\n/**\n * Apply selectors to an element.\n *\n * @param {State} state\n *   Current state.\n * @param {Array<AstRule>} rules\n *   Rules to apply.\n * @param {Element} node\n *   Element to apply rules to.\n * @param {number | undefined} index\n *   Index of `node` in `parent`.\n * @param {Parents | undefined} parent\n *   Parent of `node`.\n * @returns {Nest}\n *   Further rules.\n */\nfunction applySelectors(state, rules, node, index, parent) {\n  /** @type {Nest} */\n  const nestResult = {\n    adjacentSibling: undefined,\n    descendant: undefined,\n    directChild: undefined,\n    generalSibling: undefined\n  };\n  let selectorIndex = -1;\n  while (++selectorIndex < rules.length) {\n    const rule = rules[selectorIndex];\n\n    // We found one thing, and one is enough.\n    if (state.one && state.found) {\n      break;\n    }\n\n    // When shallow, we don’t allow nested rules.\n    // Idea: we could allow a stack of parents?\n    // Might get quite complex though.\n    if (state.shallow && rule.nestedRule) {\n      throw new Error('Expected selector without nesting');\n    }\n\n    // If this rule matches:\n    if (test(rule, node, index, parent, state)) {\n      const nest = rule.nestedRule;\n\n      // Are there more?\n      if (nest) {\n        /** @type {keyof Nest} */\n        const label = nest.combinator === '+' ? 'adjacentSibling' : nest.combinator === '~' ? 'generalSibling' : nest.combinator === '>' ? 'directChild' : 'descendant';\n        add(nestResult, label, nest);\n      } else {\n        // We have a match!\n        state.found = true;\n        if (!state.results.includes(node)) {\n          state.results.push(node);\n        }\n      }\n    }\n\n    // Descendant.\n    if (rule.combinator === undefined) {\n      add(nestResult, 'descendant', rule);\n    }\n    // Adjacent.\n    else if (rule.combinator === '~') {\n      add(nestResult, 'generalSibling', rule);\n    }\n    // Drop direct child (`>`), adjacent sibling (`+`).\n  }\n  return nestResult;\n}\n\n/**\n * Combine two lists, if needed.\n *\n * This is optimized to create as few lists as possible.\n *\n * @param {Array<AstRule> | undefined} left\n *   Rules.\n * @param {Array<AstRule> | undefined} right\n *   Rules.\n * @returns {Array<AstRule>}\n *   Rules.\n */\nfunction combine(left, right) {\n  return left && right && left.length > 0 && right.length > 0 ? [...left, ...right] : left && left.length > 0 ? left : right && right.length > 0 ? right : empty;\n}\n\n/**\n * Count a node.\n *\n * @param {Counts} counts\n *   Counts.\n * @param {Nodes} node\n *   Node (we’re looking for elements).\n * @returns {undefined}\n *   Nothing.\n */\nfunction count(counts, node) {\n  if (node.type === 'element') {\n    // Uppercase to prevent prototype polution, injecting `constructor` or so.\n    // Normalize because HTML is insensitive.\n    const name = node.tagName.toUpperCase();\n    const count = (counts.types.get(name) || 0) + 1;\n    counts.count++;\n    counts.types.set(name, count);\n  }\n}\n\n/**\n * Check a node.\n *\n * @param {State} state\n *   State.\n * @param {Array<AstRule>} currentRules\n *   Rules.\n * @param {Nodes} node\n *   Node.\n * @param {number | undefined} index\n *   Index of `node` in `parent`.\n * @param {Parents | undefined} parent\n *   Parent of `node`.\n * @param {Nodes} tree\n *   Tree.\n * @returns {Nest}\n *   Nesting.\n */\nfunction one(state, currentRules, node, index, parent, tree) {\n  /** @type {Nest} */\n  let nestResult = {\n    adjacentSibling: undefined,\n    descendant: undefined,\n    directChild: undefined,\n    generalSibling: undefined\n  };\n  const exit = enterState(state, node);\n  if (node.type === 'element') {\n    let rootRules = state.rootQuery.rules;\n\n    // Remove direct child rules if this is the root.\n    // This only happens for a `:has()` rule, which can be like\n    // `a:has(> b)`.\n    if (parent && parent !== tree) {\n      rootRules = state.rootQuery.rules.filter(d => d.combinator === undefined || d.combinator === '>' && parent === tree);\n    }\n    nestResult = applySelectors(state,\n    // Try the root rules for this element too.\n    combine(currentRules, rootRules), node, index, parent);\n  }\n\n  // If this is a parent, and we want to delve into them, and we haven’t found\n  // our single result yet.\n  if ('children' in node && !state.shallow && !(state.one && state.found)) {\n    all(state, nestResult, node, tree);\n  }\n  exit();\n  return nestResult;\n}","map":{"version":3,"names":["enterState","test","empty","walk","state","tree","one","undefined","add","nest","field","rule","list","push","all","node","fromParent","combine","descendant","directChild","fromSibling","index","total","count","types","Map","before","children","length","child","name","type","tagName","toUpperCase","elementIndex","typeIndex","get","elementCount","typeCount","forSibling","generalSibling","adjacentSibling","found","applySelectors","rules","parent","nestResult","selectorIndex","shallow","nestedRule","Error","label","combinator","results","includes","left","right","counts","set","currentRules","exit","rootRules","rootQuery","filter","d"],"sources":["/Users/mubarakmuse/Abubakar-Islamic-Institute-LMS/node_modules/hast-util-select/lib/walk.js"],"sourcesContent":["/**\n * @import {AstRule} from 'css-selector-parser'\n * @import {Element, Nodes, Parents} from 'hast'\n * @import {State} from './index.js'\n */\n\n/**\n * @typedef Counts\n *   Info on elements in a parent.\n * @property {number} count\n *   Number of elements.\n * @property {Map<string, number>} types\n *   Number of elements by tag name.\n *\n * @typedef Nest\n *   Rule sets by nesting.\n * @property {Array<AstRule> | undefined} adjacentSibling\n *   `a + b`\n * @property {Array<AstRule> | undefined} descendant\n *   `a b`\n * @property {Array<AstRule> | undefined} directChild\n *   `a > b`\n * @property {Array<AstRule> | undefined} generalSibling\n *   `a ~ b`\n */\n\nimport {enterState} from './enter-state.js'\nimport {test} from './test.js'\n\n/** @type {Array<never>} */\nconst empty = []\n\n/**\n * Walk a tree.\n *\n * @param {State} state\n *   State.\n * @param {Nodes | undefined} tree\n *   Tree.\n */\nexport function walk(state, tree) {\n  if (tree) {\n    one(state, [], tree, undefined, undefined, tree)\n  }\n}\n\n/**\n * Add a rule to a nesting map.\n *\n * @param {Nest} nest\n *   Nesting.\n * @param {keyof Nest} field\n *   Field.\n * @param {AstRule} rule\n *   Rule.\n */\nfunction add(nest, field, rule) {\n  const list = nest[field]\n  if (list) {\n    list.push(rule)\n  } else {\n    nest[field] = [rule]\n  }\n}\n\n/**\n * Check in a parent.\n *\n * @param {State} state\n *   State.\n * @param {Nest} nest\n *   Nesting.\n * @param {Parents} node\n *   Parent.\n * @param {Nodes} tree\n *   Tree.\n * @returns {undefined}\n *   Nothing.\n */\nfunction all(state, nest, node, tree) {\n  const fromParent = combine(nest.descendant, nest.directChild)\n  /** @type {Array<AstRule> | undefined} */\n  let fromSibling\n  let index = -1\n  /**\n   * Total counts.\n   * @type {Counts}\n   */\n  const total = {count: 0, types: new Map()}\n  /**\n   * Counts of previous siblings.\n   * @type {Counts}\n   */\n  const before = {count: 0, types: new Map()}\n\n  while (++index < node.children.length) {\n    count(total, node.children[index])\n  }\n\n  index = -1\n\n  while (++index < node.children.length) {\n    const child = node.children[index]\n    // Uppercase to prevent prototype polution, injecting `constructor` or so.\n    // Normalize because HTML is insensitive.\n    const name =\n      child.type === 'element' ? child.tagName.toUpperCase() : undefined\n    // Before counting further elements:\n    state.elementIndex = before.count\n    state.typeIndex = name ? before.types.get(name) || 0 : 0\n    // After counting all elements.\n    state.elementCount = total.count\n    state.typeCount = name ? total.types.get(name) : 0\n\n    // Only apply if this is a parent, this should be an element, but we check\n    // for parents so that we delve into custom nodes too.\n    if ('children' in child) {\n      const forSibling = combine(fromParent, fromSibling)\n      const nest = one(\n        state,\n        forSibling,\n        node.children[index],\n        index,\n        node,\n        tree\n      )\n      fromSibling = combine(nest.generalSibling, nest.adjacentSibling)\n    }\n\n    // We found one thing, and one is enough.\n    if (state.one && state.found) {\n      break\n    }\n\n    count(before, node.children[index])\n  }\n}\n\n/**\n * Apply selectors to an element.\n *\n * @param {State} state\n *   Current state.\n * @param {Array<AstRule>} rules\n *   Rules to apply.\n * @param {Element} node\n *   Element to apply rules to.\n * @param {number | undefined} index\n *   Index of `node` in `parent`.\n * @param {Parents | undefined} parent\n *   Parent of `node`.\n * @returns {Nest}\n *   Further rules.\n */\nfunction applySelectors(state, rules, node, index, parent) {\n  /** @type {Nest} */\n  const nestResult = {\n    adjacentSibling: undefined,\n    descendant: undefined,\n    directChild: undefined,\n    generalSibling: undefined\n  }\n  let selectorIndex = -1\n\n  while (++selectorIndex < rules.length) {\n    const rule = rules[selectorIndex]\n\n    // We found one thing, and one is enough.\n    if (state.one && state.found) {\n      break\n    }\n\n    // When shallow, we don’t allow nested rules.\n    // Idea: we could allow a stack of parents?\n    // Might get quite complex though.\n    if (state.shallow && rule.nestedRule) {\n      throw new Error('Expected selector without nesting')\n    }\n\n    // If this rule matches:\n    if (test(rule, node, index, parent, state)) {\n      const nest = rule.nestedRule\n\n      // Are there more?\n      if (nest) {\n        /** @type {keyof Nest} */\n        const label =\n          nest.combinator === '+'\n            ? 'adjacentSibling'\n            : nest.combinator === '~'\n              ? 'generalSibling'\n              : nest.combinator === '>'\n                ? 'directChild'\n                : 'descendant'\n        add(nestResult, label, nest)\n      } else {\n        // We have a match!\n        state.found = true\n\n        if (!state.results.includes(node)) {\n          state.results.push(node)\n        }\n      }\n    }\n\n    // Descendant.\n    if (rule.combinator === undefined) {\n      add(nestResult, 'descendant', rule)\n    }\n    // Adjacent.\n    else if (rule.combinator === '~') {\n      add(nestResult, 'generalSibling', rule)\n    }\n    // Drop direct child (`>`), adjacent sibling (`+`).\n  }\n\n  return nestResult\n}\n\n/**\n * Combine two lists, if needed.\n *\n * This is optimized to create as few lists as possible.\n *\n * @param {Array<AstRule> | undefined} left\n *   Rules.\n * @param {Array<AstRule> | undefined} right\n *   Rules.\n * @returns {Array<AstRule>}\n *   Rules.\n */\nfunction combine(left, right) {\n  return left && right && left.length > 0 && right.length > 0\n    ? [...left, ...right]\n    : left && left.length > 0\n      ? left\n      : right && right.length > 0\n        ? right\n        : empty\n}\n\n/**\n * Count a node.\n *\n * @param {Counts} counts\n *   Counts.\n * @param {Nodes} node\n *   Node (we’re looking for elements).\n * @returns {undefined}\n *   Nothing.\n */\nfunction count(counts, node) {\n  if (node.type === 'element') {\n    // Uppercase to prevent prototype polution, injecting `constructor` or so.\n    // Normalize because HTML is insensitive.\n    const name = node.tagName.toUpperCase()\n    const count = (counts.types.get(name) || 0) + 1\n    counts.count++\n    counts.types.set(name, count)\n  }\n}\n\n/**\n * Check a node.\n *\n * @param {State} state\n *   State.\n * @param {Array<AstRule>} currentRules\n *   Rules.\n * @param {Nodes} node\n *   Node.\n * @param {number | undefined} index\n *   Index of `node` in `parent`.\n * @param {Parents | undefined} parent\n *   Parent of `node`.\n * @param {Nodes} tree\n *   Tree.\n * @returns {Nest}\n *   Nesting.\n */\nfunction one(state, currentRules, node, index, parent, tree) {\n  /** @type {Nest} */\n  let nestResult = {\n    adjacentSibling: undefined,\n    descendant: undefined,\n    directChild: undefined,\n    generalSibling: undefined\n  }\n\n  const exit = enterState(state, node)\n\n  if (node.type === 'element') {\n    let rootRules = state.rootQuery.rules\n\n    // Remove direct child rules if this is the root.\n    // This only happens for a `:has()` rule, which can be like\n    // `a:has(> b)`.\n    if (parent && parent !== tree) {\n      rootRules = state.rootQuery.rules.filter(\n        (d) =>\n          d.combinator === undefined ||\n          (d.combinator === '>' && parent === tree)\n      )\n    }\n\n    nestResult = applySelectors(\n      state,\n      // Try the root rules for this element too.\n      combine(currentRules, rootRules),\n      node,\n      index,\n      parent\n    )\n  }\n\n  // If this is a parent, and we want to delve into them, and we haven’t found\n  // our single result yet.\n  if ('children' in node && !state.shallow && !(state.one && state.found)) {\n    all(state, nestResult, node, tree)\n  }\n\n  exit()\n\n  return nestResult\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}