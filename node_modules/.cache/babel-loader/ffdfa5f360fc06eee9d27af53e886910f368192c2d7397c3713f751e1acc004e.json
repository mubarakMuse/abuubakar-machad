{"ast":null,"code":"/**\n * @typedef {import('hast').Element} Element\n * @typedef {import('hast').ElementContent} ElementContent\n * @typedef {import('hast').Properties} Properties\n * @typedef {import('hast').Root} Root\n *\n * @typedef {import('hast-util-is-element').Test} Test\n */\n\n/**\n * @typedef {'after' | 'append' | 'before' | 'prepend' | 'wrap'} Behavior\n *   Behavior.\n *\n * @callback Build\n *   Generate content.\n * @param {Readonly<Element>} element\n *   Current heading.\n * @returns {Array<ElementContent> | ElementContent}\n *   Content.\n *\n * @callback BuildProperties\n *   Generate properties.\n * @param {Readonly<Element>} element\n *   Current heading.\n * @returns {Properties}\n *   Properties.\n *\n * @typedef Options\n *   Configuration.\n * @property {Behavior | null | undefined} [behavior='prepend']\n *   How to create links (default: `'prepend'`).\n * @property {Readonly<ElementContent> | ReadonlyArray<ElementContent> | Build | null | undefined} [content]\n *   Content to insert in the link (default: if `'wrap'` then `undefined`,\n *   otherwise `<span class=\"icon icon-link\"></span>`);\n *   if `behavior` is `'wrap'` and `Build` is passed, its result replaces the\n *   existing content, otherwise the content is added after existing content.\n * @property {Readonly<ElementContent> | ReadonlyArray<ElementContent> | Build | null | undefined} [group]\n *   Content to wrap the heading and link with, if `behavior` is `'after'` or\n *   `'before'` (optional).\n * @property {Readonly<Properties> | BuildProperties | null | undefined} [headingProperties]\n *   Extra properties to set on the heading (optional).\n * @property {Readonly<Properties> | BuildProperties | null | undefined} [properties]\n *   Extra properties to set on the link when injecting (default:\n *   `{ariaHidden: true, tabIndex: -1}` if `'append'` or `'prepend'`, otherwise\n *   `undefined`).\n * @property {Test | null | undefined} [test]\n *   Extra test for which headings are linked (optional).\n */\n\n/**\n * @template T\n *   Kind.\n * @typedef {(\n *   T extends Record<any, any>\n *     ? {-readonly [k in keyof T]: Cloneable<T[k]>}\n *     : T\n * )} Cloneable\n *   Deep clone.\n *\n *   See: <https://github.com/microsoft/TypeScript-DOM-lib-generator/issues/1237#issuecomment-1345515448>\n */\n\nimport structuredClone from '@ungap/structured-clone';\nimport { headingRank } from 'hast-util-heading-rank';\nimport { convertElement } from 'hast-util-is-element';\nimport { SKIP, visit } from 'unist-util-visit';\n\n/** @type {Element} */\nconst contentDefaults = {\n  type: 'element',\n  tagName: 'span',\n  properties: {\n    className: ['icon', 'icon-link']\n  },\n  children: []\n};\n\n/** @type {Options} */\nconst emptyOptions = {};\n\n/**\n * Add links from headings back to themselves.\n *\n * ###### Notes\n *\n * This plugin only applies to headings with `id`s.\n * Use `rehype-slug` to generate `id`s for headings that don’t have them.\n *\n * Several behaviors are supported:\n *\n * *   `'prepend'` (default) — inject link before the heading text\n * *   `'append'` — inject link after the heading text\n * *   `'wrap'` — wrap the whole heading text with the link\n * *   `'before'` — insert link before the heading\n * *   `'after'` — insert link after the heading\n *\n * @param {Readonly<Options> | null | undefined} [options]\n *   Configuration (optional).\n * @returns\n *   Transform.\n */\nexport default function rehypeAutolinkHeadings(options) {\n  const settings = options || emptyOptions;\n  let properties = settings.properties;\n  const headingOroperties = settings.headingProperties;\n  const behavior = settings.behavior || 'prepend';\n  const content = settings.content;\n  const group = settings.group;\n  const is = convertElement(settings.test);\n\n  /** @type {import('unist-util-visit').Visitor<Element>} */\n  let method;\n  if (behavior === 'after' || behavior === 'before') {\n    method = around;\n  } else if (behavior === 'wrap') {\n    method = wrap;\n  } else {\n    method = inject;\n    if (!properties) {\n      properties = {\n        ariaHidden: 'true',\n        tabIndex: -1\n      };\n    }\n  }\n\n  /**\n   * Transform.\n   *\n   * @param {Root} tree\n   *   Tree.\n   * @returns {undefined}\n   *   Nothing.\n   */\n  return function (tree) {\n    visit(tree, 'element', function (node, index, parent) {\n      if (headingRank(node) && node.properties.id && is(node, index, parent)) {\n        Object.assign(node.properties, toProperties(headingOroperties, node));\n        return method(node, index, parent);\n      }\n    });\n  };\n\n  /** @type {import('unist-util-visit').Visitor<Element>} */\n  function inject(node) {\n    const children = toChildren(content || contentDefaults, node);\n    node.children[behavior === 'prepend' ? 'unshift' : 'push'](create(node, toProperties(properties, node), children));\n    return [SKIP];\n  }\n\n  /** @type {import('unist-util-visit').Visitor<Element>} */\n  function around(node, index, parent) {\n    /* c8 ignore next -- uncommon */\n    if (typeof index !== 'number' || !parent) return;\n    const children = toChildren(content || contentDefaults, node);\n    const link = create(node, toProperties(properties, node), children);\n    let nodes = behavior === 'before' ? [link, node] : [node, link];\n    if (group) {\n      const grouping = toNode(group, node);\n      if (grouping && !Array.isArray(grouping) && grouping.type === 'element') {\n        grouping.children = nodes;\n        nodes = [grouping];\n      }\n    }\n    parent.children.splice(index, 1, ...nodes);\n    return [SKIP, index + nodes.length];\n  }\n\n  /** @type {import('unist-util-visit').Visitor<Element>} */\n  function wrap(node) {\n    /** @type {Array<ElementContent>} */\n    let before = node.children;\n    /** @type {Array<ElementContent> | ElementContent} */\n    let after = [];\n    if (typeof content === 'function') {\n      before = [];\n      after = content(node);\n    } else if (content) {\n      after = clone(content);\n    }\n    node.children = [create(node, toProperties(properties, node), Array.isArray(after) ? [...before, ...after] : [...before, after])];\n    return [SKIP];\n  }\n}\n\n/**\n * Deep clone.\n *\n * @template T\n *   Kind.\n * @param {T} thing\n *   Thing to clone.\n * @returns {Cloneable<T>}\n *   Cloned thing.\n */\nfunction clone(thing) {\n  // Cast because it’s mutable now.\n  return /** @type {Cloneable<T>} */structuredClone(thing);\n}\n\n/**\n * Create an `a`.\n *\n * @param {Readonly<Element>} node\n *   Related heading.\n * @param {Properties | undefined} properties\n *   Properties to set on the link.\n * @param {Array<ElementContent>} children\n *   Content.\n * @returns {Element}\n *   Link.\n */\nfunction create(node, properties, children) {\n  return {\n    type: 'element',\n    tagName: 'a',\n    properties: {\n      ...properties,\n      href: '#' + node.properties.id\n    },\n    children\n  };\n}\n\n/**\n * Turn into children.\n *\n * @param {Readonly<ElementContent> | ReadonlyArray<ElementContent> | Build} value\n *   Content.\n * @param {Readonly<Element>} node\n *   Related heading.\n * @returns {Array<ElementContent>}\n *   Children.\n */\nfunction toChildren(value, node) {\n  const result = toNode(value, node);\n  return Array.isArray(result) ? result : [result];\n}\n\n/**\n * Turn into a node.\n *\n * @param {Readonly<ElementContent> | ReadonlyArray<ElementContent> | Build} value\n *   Content.\n * @param {Readonly<Element>} node\n *   Related heading.\n * @returns {Array<ElementContent> | ElementContent}\n *   Node.\n */\nfunction toNode(value, node) {\n  if (typeof value === 'function') return value(node);\n  return clone(value);\n}\n\n/**\n * Turn into properties.\n *\n * @param {Readonly<Properties> | BuildProperties | null | undefined} value\n *   Properties.\n * @param {Readonly<Element>} node\n *   Related heading.\n * @returns {Properties}\n *   Properties.\n */\nfunction toProperties(value, node) {\n  if (typeof value === 'function') return value(node);\n  return value ? clone(value) : {};\n}","map":{"version":3,"names":["structuredClone","headingRank","convertElement","SKIP","visit","contentDefaults","type","tagName","properties","className","children","emptyOptions","rehypeAutolinkHeadings","options","settings","headingOroperties","headingProperties","behavior","content","group","is","test","method","around","wrap","inject","ariaHidden","tabIndex","tree","node","index","parent","id","Object","assign","toProperties","toChildren","create","link","nodes","grouping","toNode","Array","isArray","splice","length","before","after","clone","thing","href","value","result"],"sources":["/Users/mubarakmuse/Abubakar-Islamic-Institute-LMS/node_modules/rehype-autolink-headings/lib/index.js"],"sourcesContent":["/**\n * @typedef {import('hast').Element} Element\n * @typedef {import('hast').ElementContent} ElementContent\n * @typedef {import('hast').Properties} Properties\n * @typedef {import('hast').Root} Root\n *\n * @typedef {import('hast-util-is-element').Test} Test\n */\n\n/**\n * @typedef {'after' | 'append' | 'before' | 'prepend' | 'wrap'} Behavior\n *   Behavior.\n *\n * @callback Build\n *   Generate content.\n * @param {Readonly<Element>} element\n *   Current heading.\n * @returns {Array<ElementContent> | ElementContent}\n *   Content.\n *\n * @callback BuildProperties\n *   Generate properties.\n * @param {Readonly<Element>} element\n *   Current heading.\n * @returns {Properties}\n *   Properties.\n *\n * @typedef Options\n *   Configuration.\n * @property {Behavior | null | undefined} [behavior='prepend']\n *   How to create links (default: `'prepend'`).\n * @property {Readonly<ElementContent> | ReadonlyArray<ElementContent> | Build | null | undefined} [content]\n *   Content to insert in the link (default: if `'wrap'` then `undefined`,\n *   otherwise `<span class=\"icon icon-link\"></span>`);\n *   if `behavior` is `'wrap'` and `Build` is passed, its result replaces the\n *   existing content, otherwise the content is added after existing content.\n * @property {Readonly<ElementContent> | ReadonlyArray<ElementContent> | Build | null | undefined} [group]\n *   Content to wrap the heading and link with, if `behavior` is `'after'` or\n *   `'before'` (optional).\n * @property {Readonly<Properties> | BuildProperties | null | undefined} [headingProperties]\n *   Extra properties to set on the heading (optional).\n * @property {Readonly<Properties> | BuildProperties | null | undefined} [properties]\n *   Extra properties to set on the link when injecting (default:\n *   `{ariaHidden: true, tabIndex: -1}` if `'append'` or `'prepend'`, otherwise\n *   `undefined`).\n * @property {Test | null | undefined} [test]\n *   Extra test for which headings are linked (optional).\n */\n\n/**\n * @template T\n *   Kind.\n * @typedef {(\n *   T extends Record<any, any>\n *     ? {-readonly [k in keyof T]: Cloneable<T[k]>}\n *     : T\n * )} Cloneable\n *   Deep clone.\n *\n *   See: <https://github.com/microsoft/TypeScript-DOM-lib-generator/issues/1237#issuecomment-1345515448>\n */\n\nimport structuredClone from '@ungap/structured-clone'\nimport {headingRank} from 'hast-util-heading-rank'\nimport {convertElement} from 'hast-util-is-element'\nimport {SKIP, visit} from 'unist-util-visit'\n\n/** @type {Element} */\nconst contentDefaults = {\n  type: 'element',\n  tagName: 'span',\n  properties: {className: ['icon', 'icon-link']},\n  children: []\n}\n\n/** @type {Options} */\nconst emptyOptions = {}\n\n/**\n * Add links from headings back to themselves.\n *\n * ###### Notes\n *\n * This plugin only applies to headings with `id`s.\n * Use `rehype-slug` to generate `id`s for headings that don’t have them.\n *\n * Several behaviors are supported:\n *\n * *   `'prepend'` (default) — inject link before the heading text\n * *   `'append'` — inject link after the heading text\n * *   `'wrap'` — wrap the whole heading text with the link\n * *   `'before'` — insert link before the heading\n * *   `'after'` — insert link after the heading\n *\n * @param {Readonly<Options> | null | undefined} [options]\n *   Configuration (optional).\n * @returns\n *   Transform.\n */\nexport default function rehypeAutolinkHeadings(options) {\n  const settings = options || emptyOptions\n  let properties = settings.properties\n  const headingOroperties = settings.headingProperties\n  const behavior = settings.behavior || 'prepend'\n  const content = settings.content\n  const group = settings.group\n  const is = convertElement(settings.test)\n\n  /** @type {import('unist-util-visit').Visitor<Element>} */\n  let method\n\n  if (behavior === 'after' || behavior === 'before') {\n    method = around\n  } else if (behavior === 'wrap') {\n    method = wrap\n  } else {\n    method = inject\n\n    if (!properties) {\n      properties = {ariaHidden: 'true', tabIndex: -1}\n    }\n  }\n\n  /**\n   * Transform.\n   *\n   * @param {Root} tree\n   *   Tree.\n   * @returns {undefined}\n   *   Nothing.\n   */\n  return function (tree) {\n    visit(tree, 'element', function (node, index, parent) {\n      if (headingRank(node) && node.properties.id && is(node, index, parent)) {\n        Object.assign(node.properties, toProperties(headingOroperties, node))\n        return method(node, index, parent)\n      }\n    })\n  }\n\n  /** @type {import('unist-util-visit').Visitor<Element>} */\n  function inject(node) {\n    const children = toChildren(content || contentDefaults, node)\n    node.children[behavior === 'prepend' ? 'unshift' : 'push'](\n      create(node, toProperties(properties, node), children)\n    )\n\n    return [SKIP]\n  }\n\n  /** @type {import('unist-util-visit').Visitor<Element>} */\n  function around(node, index, parent) {\n    /* c8 ignore next -- uncommon */\n    if (typeof index !== 'number' || !parent) return\n\n    const children = toChildren(content || contentDefaults, node)\n    const link = create(node, toProperties(properties, node), children)\n    let nodes = behavior === 'before' ? [link, node] : [node, link]\n\n    if (group) {\n      const grouping = toNode(group, node)\n\n      if (grouping && !Array.isArray(grouping) && grouping.type === 'element') {\n        grouping.children = nodes\n        nodes = [grouping]\n      }\n    }\n\n    parent.children.splice(index, 1, ...nodes)\n\n    return [SKIP, index + nodes.length]\n  }\n\n  /** @type {import('unist-util-visit').Visitor<Element>} */\n  function wrap(node) {\n    /** @type {Array<ElementContent>} */\n    let before = node.children\n    /** @type {Array<ElementContent> | ElementContent} */\n    let after = []\n\n    if (typeof content === 'function') {\n      before = []\n      after = content(node)\n    } else if (content) {\n      after = clone(content)\n    }\n\n    node.children = [\n      create(\n        node,\n        toProperties(properties, node),\n        Array.isArray(after) ? [...before, ...after] : [...before, after]\n      )\n    ]\n\n    return [SKIP]\n  }\n}\n\n/**\n * Deep clone.\n *\n * @template T\n *   Kind.\n * @param {T} thing\n *   Thing to clone.\n * @returns {Cloneable<T>}\n *   Cloned thing.\n */\nfunction clone(thing) {\n  // Cast because it’s mutable now.\n  return /** @type {Cloneable<T>} */ (structuredClone(thing))\n}\n\n/**\n * Create an `a`.\n *\n * @param {Readonly<Element>} node\n *   Related heading.\n * @param {Properties | undefined} properties\n *   Properties to set on the link.\n * @param {Array<ElementContent>} children\n *   Content.\n * @returns {Element}\n *   Link.\n */\nfunction create(node, properties, children) {\n  return {\n    type: 'element',\n    tagName: 'a',\n    properties: {...properties, href: '#' + node.properties.id},\n    children\n  }\n}\n\n/**\n * Turn into children.\n *\n * @param {Readonly<ElementContent> | ReadonlyArray<ElementContent> | Build} value\n *   Content.\n * @param {Readonly<Element>} node\n *   Related heading.\n * @returns {Array<ElementContent>}\n *   Children.\n */\nfunction toChildren(value, node) {\n  const result = toNode(value, node)\n  return Array.isArray(result) ? result : [result]\n}\n\n/**\n * Turn into a node.\n *\n * @param {Readonly<ElementContent> | ReadonlyArray<ElementContent> | Build} value\n *   Content.\n * @param {Readonly<Element>} node\n *   Related heading.\n * @returns {Array<ElementContent> | ElementContent}\n *   Node.\n */\nfunction toNode(value, node) {\n  if (typeof value === 'function') return value(node)\n  return clone(value)\n}\n\n/**\n * Turn into properties.\n *\n * @param {Readonly<Properties> | BuildProperties | null | undefined} value\n *   Properties.\n * @param {Readonly<Element>} node\n *   Related heading.\n * @returns {Properties}\n *   Properties.\n */\nfunction toProperties(value, node) {\n  if (typeof value === 'function') return value(node)\n  return value ? clone(value) : {}\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}