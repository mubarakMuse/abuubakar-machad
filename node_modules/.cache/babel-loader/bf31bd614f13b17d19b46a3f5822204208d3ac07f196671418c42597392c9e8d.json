{"ast":null,"code":"import { createMulticharIndex, createRegularIndex, emptyMulticharIndex, emptyRegularIndex } from './indexes.js';\nimport { calculatePseudoSignatures, defaultPseudoSignature, emptyPseudoSignatures } from './pseudo-signatures.js';\nimport { cssSyntaxDefinitions, extendSyntaxDefinition, getXmlOptions, cssModules, pseudoLocationIndex } from './syntax-definitions.js';\nimport { digitsChars, isHex, isIdent, isIdentStart, maxHexLength, quoteChars, whitespaceChars } from './utils.js';\nvar errorPrefix = \"css-selector-parser parse error: \";\n/**\n * Creates a parse function to be used later to parse CSS selectors.\n */\nexport function createParser(options) {\n  if (options === void 0) {\n    options = {};\n  }\n  var _a = options.syntax,\n    syntax = _a === void 0 ? 'latest' : _a,\n    substitutes = options.substitutes,\n    _b = options.strict,\n    strict = _b === void 0 ? true : _b,\n    modules = options.modules;\n  var syntaxDefinition = typeof syntax === 'object' ? syntax : cssSyntaxDefinitions[syntax];\n  if (syntaxDefinition.baseSyntax) {\n    syntaxDefinition = extendSyntaxDefinition(cssSyntaxDefinitions[syntaxDefinition.baseSyntax], syntaxDefinition);\n  }\n  // Apply modules from syntax definition\n  if (syntaxDefinition.modules && syntaxDefinition.modules.length > 0) {\n    for (var _i = 0, _c = syntaxDefinition.modules; _i < _c.length; _i++) {\n      var module_1 = _c[_i];\n      var moduleSyntax = cssModules[module_1];\n      if (moduleSyntax) {\n        syntaxDefinition = extendSyntaxDefinition(moduleSyntax, syntaxDefinition);\n      }\n    }\n  }\n  // Apply additional modules if specified from options\n  if (modules && modules.length > 0) {\n    for (var _d = 0, modules_1 = modules; _d < modules_1.length; _d++) {\n      var module_2 = modules_1[_d];\n      var moduleSyntax = cssModules[module_2];\n      if (moduleSyntax) {\n        syntaxDefinition = extendSyntaxDefinition(moduleSyntax, syntaxDefinition);\n      }\n    }\n  }\n  var _e = syntaxDefinition.tag ? [true, Boolean(getXmlOptions(syntaxDefinition.tag).wildcard)] : [false, false],\n    tagNameEnabled = _e[0],\n    tagNameWildcardEnabled = _e[1];\n  var idEnabled = Boolean(syntaxDefinition.ids);\n  var classNamesEnabled = Boolean(syntaxDefinition.classNames);\n  var namespaceEnabled = Boolean(syntaxDefinition.namespace);\n  var namespaceWildcardEnabled = syntaxDefinition.namespace && (syntaxDefinition.namespace === true || syntaxDefinition.namespace.wildcard === true);\n  if (namespaceEnabled && !tagNameEnabled) {\n    throw new Error(\"\".concat(errorPrefix, \"Namespaces cannot be enabled while tags are disabled.\"));\n  }\n  var substitutesEnabled = Boolean(substitutes);\n  var combinatorsIndex = syntaxDefinition.combinators ? createMulticharIndex(syntaxDefinition.combinators) : emptyMulticharIndex;\n  var _f = syntaxDefinition.attributes ? [true, syntaxDefinition.attributes.operators ? createMulticharIndex(syntaxDefinition.attributes.operators) : emptyMulticharIndex, syntaxDefinition.attributes.caseSensitivityModifiers ? createRegularIndex(syntaxDefinition.attributes.caseSensitivityModifiers) : emptyRegularIndex, syntaxDefinition.attributes.unknownCaseSensitivityModifiers === 'accept'] : [false, emptyMulticharIndex, emptyRegularIndex, false],\n    attributesEnabled = _f[0],\n    attributesOperatorsIndex = _f[1],\n    attributesCaseSensitivityModifiers = _f[2],\n    attributesAcceptUnknownCaseSensitivityModifiers = _f[3];\n  var attributesCaseSensitivityModifiersEnabled = attributesAcceptUnknownCaseSensitivityModifiers || Object.keys(attributesCaseSensitivityModifiers).length > 0;\n  var _g = syntaxDefinition.pseudoClasses ? [true, syntaxDefinition.pseudoClasses.definitions ? calculatePseudoSignatures(syntaxDefinition.pseudoClasses.definitions) : emptyPseudoSignatures, syntaxDefinition.pseudoClasses.unknown === 'accept'] : [false, emptyPseudoSignatures, false],\n    pseudoClassesEnabled = _g[0],\n    pseudoClassesDefinitions = _g[1],\n    pseudoClassesAcceptUnknown = _g[2];\n  var _h = syntaxDefinition.pseudoElements ? [true, syntaxDefinition.pseudoElements.notation === 'singleColon' || syntaxDefinition.pseudoElements.notation === 'both', !syntaxDefinition.pseudoElements.notation || syntaxDefinition.pseudoElements.notation === 'doubleColon' || syntaxDefinition.pseudoElements.notation === 'both', syntaxDefinition.pseudoElements.definitions ? calculatePseudoSignatures(Array.isArray(syntaxDefinition.pseudoElements.definitions) ? {\n      NoArgument: syntaxDefinition.pseudoElements.definitions\n    } : syntaxDefinition.pseudoElements.definitions) : emptyPseudoSignatures, syntaxDefinition.pseudoElements.unknown === 'accept'] : [false, false, false, emptyPseudoSignatures, false],\n    pseudoElementsEnabled = _h[0],\n    pseudoElementsSingleColonNotationEnabled = _h[1],\n    pseudoElementsDoubleColonNotationEnabled = _h[2],\n    pseudoElementsDefinitions = _h[3],\n    pseudoElementsAcceptUnknown = _h[4];\n  var str = '';\n  var l = str.length;\n  var pos = 0;\n  var chr = '';\n  var is = function (comparison) {\n    return chr === comparison;\n  };\n  var isTagStart = function () {\n    return is('*') || isIdentStart(chr);\n  };\n  var rewind = function (newPos) {\n    pos = newPos;\n    chr = str.charAt(pos);\n  };\n  var next = function () {\n    pos++;\n    chr = str.charAt(pos);\n  };\n  var readAndNext = function () {\n    var current = chr;\n    pos++;\n    chr = str.charAt(pos);\n    return current;\n  };\n  /** @throws ParserError */\n  function fail(errorMessage) {\n    var position = Math.min(l - 1, pos);\n    var error = new Error(\"\".concat(errorPrefix).concat(errorMessage, \" Pos: \").concat(position, \".\"));\n    error.position = position;\n    error.name = 'ParserError';\n    throw error;\n  }\n  function assert(condition, errorMessage) {\n    if (!condition) {\n      return fail(errorMessage);\n    }\n  }\n  var assertNonEof = function () {\n    assert(pos < l, 'Unexpected end of input.');\n  };\n  var isEof = function () {\n    return pos >= l;\n  };\n  var pass = function (character) {\n    assert(pos < l, \"Expected \\\"\".concat(character, \"\\\" but end of input reached.\"));\n    assert(chr === character, \"Expected \\\"\".concat(character, \"\\\" but \\\"\").concat(chr, \"\\\" found.\"));\n    pos++;\n    chr = str.charAt(pos);\n  };\n  function matchMulticharIndex(index) {\n    var match = matchMulticharIndexPos(index, pos);\n    if (match) {\n      pos += match.length;\n      chr = str.charAt(pos);\n      return match;\n    }\n  }\n  function matchMulticharIndexPos(index, subPos) {\n    var char = str.charAt(subPos);\n    var charIndex = index[char];\n    if (charIndex) {\n      var subMatch = matchMulticharIndexPos(charIndex.chars, subPos + 1);\n      if (subMatch) {\n        return subMatch;\n      }\n      if (charIndex.self) {\n        return charIndex.self;\n      }\n    }\n  }\n  /**\n   * @see https://www.w3.org/TR/css-syntax/#hex-digit-diagram\n   */\n  function parseHex() {\n    var hex = readAndNext();\n    var count = 1;\n    while (isHex(chr) && count < maxHexLength) {\n      hex += readAndNext();\n      count++;\n    }\n    skipSingleWhitespace();\n    return String.fromCharCode(parseInt(hex, 16));\n  }\n  /**\n   * @see https://www.w3.org/TR/css-syntax/#string-token-diagram\n   */\n  function parseString(quote) {\n    var result = '';\n    pass(quote);\n    while (pos < l) {\n      if (is(quote)) {\n        next();\n        return result;\n      } else if (is('\\\\')) {\n        next();\n        if (is(quote)) {\n          result += quote;\n          next();\n        } else if (chr === '\\n' || chr === '\\f') {\n          next();\n        } else if (chr === '\\r') {\n          next();\n          if (is('\\n')) {\n            next();\n          }\n        } else if (isHex(chr)) {\n          result += parseHex();\n        } else {\n          result += chr;\n          next();\n        }\n      } else {\n        result += chr;\n        next();\n      }\n    }\n    return result;\n  }\n  /**\n   * @see https://www.w3.org/TR/css-syntax/#ident-token-diagram\n   */\n  function parseIdentifier() {\n    if (!isIdentStart(chr)) {\n      return null;\n    }\n    var result = '';\n    while (is('-')) {\n      result += chr;\n      next();\n    }\n    if (result === '-' && !isIdent(chr) && !is('\\\\')) {\n      fail('Identifiers cannot consist of a single hyphen.');\n    }\n    if (strict && result.length >= 2) {\n      // Checking this only for strict mode since browsers work fine with these identifiers.\n      fail('Identifiers cannot start with two hyphens with strict mode on.');\n    }\n    if (digitsChars[chr]) {\n      fail('Identifiers cannot start with hyphens followed by digits.');\n    }\n    while (pos < l) {\n      if (isIdent(chr)) {\n        result += readAndNext();\n      } else if (is('\\\\')) {\n        next();\n        assertNonEof();\n        if (isHex(chr)) {\n          result += parseHex();\n        } else {\n          result += readAndNext();\n        }\n      } else {\n        break;\n      }\n    }\n    return result;\n  }\n  function parsePseudoClassString() {\n    var result = '';\n    while (pos < l) {\n      if (is(')')) {\n        break;\n      } else if (is('\\\\')) {\n        next();\n        if (isEof() && !strict) {\n          return (result + '\\\\').trim();\n        }\n        assertNonEof();\n        if (isHex(chr)) {\n          result += parseHex();\n        } else {\n          result += readAndNext();\n        }\n      } else {\n        result += readAndNext();\n      }\n    }\n    return result.trim();\n  }\n  function skipSingleWhitespace() {\n    if (chr === ' ' || chr === '\\t' || chr === '\\f' || chr === '\\n') {\n      next();\n      return;\n    }\n    if (chr === '\\r') {\n      next();\n    }\n    if (chr === '\\n') {\n      next();\n    }\n  }\n  function skipWhitespace() {\n    while (whitespaceChars[chr]) {\n      next();\n    }\n  }\n  function parseSelector(relative) {\n    if (relative === void 0) {\n      relative = false;\n    }\n    skipWhitespace();\n    var rules = [parseRule(relative)];\n    while (is(',')) {\n      next();\n      skipWhitespace();\n      rules.push(parseRule(relative));\n    }\n    return {\n      type: 'Selector',\n      rules: rules\n    };\n  }\n  function parseAttribute() {\n    pass('[');\n    skipWhitespace();\n    var attr;\n    if (is('|')) {\n      assert(namespaceEnabled, 'Namespaces are not enabled.');\n      next();\n      var name_1 = parseIdentifier();\n      assert(name_1, 'Expected attribute name.');\n      attr = {\n        type: 'Attribute',\n        name: name_1,\n        namespace: {\n          type: 'NoNamespace'\n        }\n      };\n    } else if (is('*')) {\n      assert(namespaceEnabled, 'Namespaces are not enabled.');\n      assert(namespaceWildcardEnabled, 'Wildcard namespace is not enabled.');\n      next();\n      pass('|');\n      var name_2 = parseIdentifier();\n      assert(name_2, 'Expected attribute name.');\n      attr = {\n        type: 'Attribute',\n        name: name_2,\n        namespace: {\n          type: 'WildcardNamespace'\n        }\n      };\n    } else {\n      var identifier = parseIdentifier();\n      assert(identifier, 'Expected attribute name.');\n      attr = {\n        type: 'Attribute',\n        name: identifier\n      };\n      if (is('|')) {\n        var savedPos = pos;\n        next();\n        if (isIdentStart(chr)) {\n          assert(namespaceEnabled, 'Namespaces are not enabled.');\n          var name_3 = parseIdentifier();\n          assert(name_3, 'Expected attribute name.');\n          attr = {\n            type: 'Attribute',\n            name: name_3,\n            namespace: {\n              type: 'NamespaceName',\n              name: identifier\n            }\n          };\n        } else {\n          rewind(savedPos);\n        }\n      }\n    }\n    assert(attr.name, 'Expected attribute name.');\n    skipWhitespace();\n    if (isEof() && !strict) {\n      return attr;\n    }\n    if (is(']')) {\n      next();\n    } else {\n      attr.operator = matchMulticharIndex(attributesOperatorsIndex);\n      assert(attr.operator, 'Expected a valid attribute selector operator.');\n      skipWhitespace();\n      assertNonEof();\n      if (quoteChars[chr]) {\n        attr.value = {\n          type: 'String',\n          value: parseString(chr)\n        };\n      } else if (substitutesEnabled && is('$')) {\n        next();\n        var name_4 = parseIdentifier();\n        assert(name_4, 'Expected substitute name.');\n        attr.value = {\n          type: 'Substitution',\n          name: name_4\n        };\n      } else {\n        var value = parseIdentifier();\n        assert(value, 'Expected attribute value.');\n        attr.value = {\n          type: 'String',\n          value: value\n        };\n      }\n      skipWhitespace();\n      if (isEof() && !strict) {\n        return attr;\n      }\n      if (!is(']')) {\n        var caseSensitivityModifier = parseIdentifier();\n        assert(caseSensitivityModifier, 'Expected end of attribute selector.');\n        attr.caseSensitivityModifier = caseSensitivityModifier;\n        assert(attributesCaseSensitivityModifiersEnabled, 'Attribute case sensitivity modifiers are not enabled.');\n        assert(attributesAcceptUnknownCaseSensitivityModifiers || attributesCaseSensitivityModifiers[attr.caseSensitivityModifier], 'Unknown attribute case sensitivity modifier.');\n        skipWhitespace();\n        if (isEof() && !strict) {\n          return attr;\n        }\n      }\n      pass(']');\n    }\n    return attr;\n  }\n  function parseNumber() {\n    var result = '';\n    while (digitsChars[chr]) {\n      result += readAndNext();\n    }\n    assert(result !== '', 'Formula parse error.');\n    return parseInt(result);\n  }\n  var isNumberStart = function () {\n    return is('-') || is('+') || digitsChars[chr];\n  };\n  function parseFormula() {\n    if (is('e') || is('o')) {\n      var ident = parseIdentifier();\n      if (ident === 'even') {\n        skipWhitespace();\n        return [2, 0];\n      }\n      if (ident === 'odd') {\n        skipWhitespace();\n        return [2, 1];\n      }\n    }\n    var firstNumber = null;\n    var firstNumberMultiplier = 1;\n    if (is('-')) {\n      next();\n      firstNumberMultiplier = -1;\n    }\n    if (isNumberStart()) {\n      if (is('+')) {\n        next();\n      }\n      firstNumber = parseNumber();\n      if (!is('\\\\') && !is('n')) {\n        return [0, firstNumber * firstNumberMultiplier];\n      }\n    }\n    if (firstNumber === null) {\n      firstNumber = 1;\n    }\n    firstNumber *= firstNumberMultiplier;\n    var identifier;\n    if (is('\\\\')) {\n      next();\n      if (isHex(chr)) {\n        identifier = parseHex();\n      } else {\n        identifier = readAndNext();\n      }\n    } else {\n      identifier = readAndNext();\n    }\n    assert(identifier === 'n', 'Formula parse error: expected \"n\".');\n    skipWhitespace();\n    if (is('+') || is('-')) {\n      var sign = is('+') ? 1 : -1;\n      next();\n      skipWhitespace();\n      return [firstNumber, sign * parseNumber()];\n    } else {\n      return [firstNumber, 0];\n    }\n  }\n  function parsePseudoArgument(pseudoName, type, signature) {\n    var argument;\n    if (is('(')) {\n      next();\n      skipWhitespace();\n      if (substitutesEnabled && is('$')) {\n        next();\n        var name_5 = parseIdentifier();\n        assert(name_5, 'Expected substitute name.');\n        argument = {\n          type: 'Substitution',\n          name: name_5\n        };\n      } else if (signature.type === 'String') {\n        argument = {\n          type: 'String',\n          value: parsePseudoClassString()\n        };\n        assert(argument.value, \"Expected \".concat(type, \" argument value.\"));\n      } else if (signature.type === 'Selector') {\n        argument = parseSelector(true);\n      } else if (signature.type === 'Formula') {\n        var _a = parseFormula(),\n          a = _a[0],\n          b = _a[1];\n        argument = {\n          type: 'Formula',\n          a: a,\n          b: b\n        };\n        if (signature.ofSelector) {\n          skipWhitespace();\n          if (is('o') || is('\\\\')) {\n            var ident = parseIdentifier();\n            assert(ident === 'of', 'Formula of selector parse error.');\n            skipWhitespace();\n            argument = {\n              type: 'FormulaOfSelector',\n              a: a,\n              b: b,\n              selector: parseRule()\n            };\n          }\n        }\n      } else {\n        return fail(\"Invalid \".concat(type, \" signature.\"));\n      }\n      skipWhitespace();\n      if (isEof() && !strict) {\n        return argument;\n      }\n      pass(')');\n    } else {\n      assert(signature.optional, \"Argument is required for \".concat(type, \" \\\"\").concat(pseudoName, \"\\\".\"));\n    }\n    return argument;\n  }\n  function parseTagName() {\n    if (is('*')) {\n      assert(tagNameWildcardEnabled, 'Wildcard tag name is not enabled.');\n      next();\n      return {\n        type: 'WildcardTag'\n      };\n    } else if (isIdentStart(chr)) {\n      assert(tagNameEnabled, 'Tag names are not enabled.');\n      var name_6 = parseIdentifier();\n      assert(name_6, 'Expected tag name.');\n      return {\n        type: 'TagName',\n        name: name_6\n      };\n    } else {\n      return fail('Expected tag name.');\n    }\n  }\n  function parseTagNameWithNamespace() {\n    if (is('*')) {\n      var savedPos = pos;\n      next();\n      if (!is('|')) {\n        rewind(savedPos);\n        return parseTagName();\n      }\n      next();\n      if (!isTagStart()) {\n        rewind(savedPos);\n        return parseTagName();\n      }\n      assert(namespaceEnabled, 'Namespaces are not enabled.');\n      assert(namespaceWildcardEnabled, 'Wildcard namespace is not enabled.');\n      var tagName = parseTagName();\n      tagName.namespace = {\n        type: 'WildcardNamespace'\n      };\n      return tagName;\n    } else if (is('|')) {\n      assert(namespaceEnabled, 'Namespaces are not enabled.');\n      next();\n      var tagName = parseTagName();\n      tagName.namespace = {\n        type: 'NoNamespace'\n      };\n      return tagName;\n    } else if (isIdentStart(chr)) {\n      var identifier = parseIdentifier();\n      assert(identifier, 'Expected tag name.');\n      if (!is('|')) {\n        assert(tagNameEnabled, 'Tag names are not enabled.');\n        return {\n          type: 'TagName',\n          name: identifier\n        };\n      }\n      var savedPos = pos;\n      next();\n      if (!isTagStart()) {\n        rewind(savedPos);\n        return {\n          type: 'TagName',\n          name: identifier\n        };\n      }\n      assert(namespaceEnabled, 'Namespaces are not enabled.');\n      var tagName = parseTagName();\n      tagName.namespace = {\n        type: 'NamespaceName',\n        name: identifier\n      };\n      return tagName;\n    } else {\n      return fail('Expected tag name.');\n    }\n  }\n  function parseRule(relative) {\n    var _a, _b;\n    if (relative === void 0) {\n      relative = false;\n    }\n    var rule = {\n      type: 'Rule',\n      items: []\n    };\n    if (relative) {\n      var combinator = matchMulticharIndex(combinatorsIndex);\n      if (combinator) {\n        rule.combinator = combinator;\n        skipWhitespace();\n      }\n    }\n    while (pos < l) {\n      if (isTagStart()) {\n        assert(rule.items.length === 0, 'Unexpected tag/namespace start.');\n        rule.items.push(parseTagNameWithNamespace());\n      } else if (is('|')) {\n        var savedPos = pos;\n        next();\n        if (isTagStart()) {\n          assert(rule.items.length === 0, 'Unexpected tag/namespace start.');\n          rewind(savedPos);\n          rule.items.push(parseTagNameWithNamespace());\n        } else {\n          rewind(savedPos);\n          break;\n        }\n      } else if (is('.')) {\n        assert(classNamesEnabled, 'Class names are not enabled.');\n        next();\n        var className = parseIdentifier();\n        assert(className, 'Expected class name.');\n        rule.items.push({\n          type: 'ClassName',\n          name: className\n        });\n      } else if (is('#')) {\n        assert(idEnabled, 'IDs are not enabled.');\n        next();\n        var idName = parseIdentifier();\n        assert(idName, 'Expected ID name.');\n        rule.items.push({\n          type: 'Id',\n          name: idName\n        });\n      } else if (is('[')) {\n        assert(attributesEnabled, 'Attributes are not enabled.');\n        rule.items.push(parseAttribute());\n      } else if (is(':')) {\n        var isDoubleColon = false;\n        var isPseudoElement = false;\n        next();\n        if (is(':')) {\n          assert(pseudoElementsEnabled, 'Pseudo elements are not enabled.');\n          assert(pseudoElementsDoubleColonNotationEnabled, 'Pseudo elements double colon notation is not enabled.');\n          isDoubleColon = true;\n          next();\n        }\n        var pseudoName = parseIdentifier();\n        assert(isDoubleColon || pseudoName, 'Expected pseudo-class name.');\n        assert(!isDoubleColon || pseudoName, 'Expected pseudo-element name.');\n        assert(pseudoName, 'Expected pseudo-class name.');\n        if (!isDoubleColon || pseudoElementsAcceptUnknown || Object.prototype.hasOwnProperty.call(pseudoElementsDefinitions, pseudoName)) {\n          // All good\n        } else {\n          // Generate a helpful error message with location information\n          var locations = pseudoLocationIndex.pseudoElements[pseudoName];\n          var errorMessage = \"Unknown pseudo-element \\\"\".concat(pseudoName, \"\\\"\");\n          if (locations && locations.length > 0) {\n            errorMessage += \". It is defined in: \".concat(locations.join(', '));\n          }\n          fail(errorMessage + '.');\n        }\n        isPseudoElement = pseudoElementsEnabled && (isDoubleColon || !isDoubleColon && pseudoElementsSingleColonNotationEnabled && Object.prototype.hasOwnProperty.call(pseudoElementsDefinitions, pseudoName));\n        if (isPseudoElement) {\n          var signature = (_a = pseudoElementsDefinitions[pseudoName]) !== null && _a !== void 0 ? _a : pseudoElementsAcceptUnknown && defaultPseudoSignature;\n          var pseudoElement = {\n            type: 'PseudoElement',\n            name: pseudoName\n          };\n          var argument = parsePseudoArgument(pseudoName, 'pseudo-element', signature);\n          if (argument) {\n            assert(argument.type !== 'Formula' && argument.type !== 'FormulaOfSelector', 'Pseudo-elements cannot have formula argument.');\n            pseudoElement.argument = argument;\n          }\n          rule.items.push(pseudoElement);\n        } else {\n          assert(pseudoClassesEnabled, 'Pseudo-classes are not enabled.');\n          var signature = (_b = pseudoClassesDefinitions[pseudoName]) !== null && _b !== void 0 ? _b : pseudoClassesAcceptUnknown && defaultPseudoSignature;\n          if (signature) {\n            // All good\n          } else {\n            // Generate a helpful error message with location information\n            var locations = pseudoLocationIndex.pseudoClasses[pseudoName];\n            var errorMessage = \"Unknown pseudo-class: \\\"\".concat(pseudoName, \"\\\"\");\n            if (locations && locations.length > 0) {\n              errorMessage += \". It is defined in: \".concat(locations.join(', '));\n            }\n            fail(errorMessage + '.');\n          }\n          var argument = parsePseudoArgument(pseudoName, 'pseudo-class', signature);\n          var pseudoClass = {\n            type: 'PseudoClass',\n            name: pseudoName\n          };\n          if (argument) {\n            pseudoClass.argument = argument;\n          }\n          rule.items.push(pseudoClass);\n        }\n      } else {\n        break;\n      }\n    }\n    if (rule.items.length === 0) {\n      if (isEof()) {\n        return fail('Expected rule but end of input reached.');\n      } else {\n        return fail(\"Expected rule but \\\"\".concat(chr, \"\\\" found.\"));\n      }\n    }\n    skipWhitespace();\n    if (!isEof() && !is(',') && !is(')')) {\n      var combinator = matchMulticharIndex(combinatorsIndex);\n      skipWhitespace();\n      rule.nestedRule = parseRule();\n      rule.nestedRule.combinator = combinator;\n    }\n    return rule;\n  }\n  return function (input) {\n    // noinspection SuspiciousTypeOfGuard\n    if (typeof input !== 'string') {\n      throw new Error(\"\".concat(errorPrefix, \"Expected string input.\"));\n    }\n    str = input;\n    l = str.length;\n    pos = 0;\n    chr = str.charAt(0);\n    return parseSelector();\n  };\n}","map":{"version":3,"names":["createMulticharIndex","createRegularIndex","emptyMulticharIndex","emptyRegularIndex","calculatePseudoSignatures","defaultPseudoSignature","emptyPseudoSignatures","cssSyntaxDefinitions","extendSyntaxDefinition","getXmlOptions","cssModules","pseudoLocationIndex","digitsChars","isHex","isIdent","isIdentStart","maxHexLength","quoteChars","whitespaceChars","errorPrefix","createParser","options","_a","syntax","substitutes","_b","strict","modules","syntaxDefinition","baseSyntax","length","_i","_c","module_1","moduleSyntax","_d","modules_1","module_2","_e","tag","Boolean","wildcard","tagNameEnabled","tagNameWildcardEnabled","idEnabled","ids","classNamesEnabled","classNames","namespaceEnabled","namespace","namespaceWildcardEnabled","Error","concat","substitutesEnabled","combinatorsIndex","combinators","_f","attributes","operators","caseSensitivityModifiers","unknownCaseSensitivityModifiers","attributesEnabled","attributesOperatorsIndex","attributesCaseSensitivityModifiers","attributesAcceptUnknownCaseSensitivityModifiers","attributesCaseSensitivityModifiersEnabled","Object","keys","_g","pseudoClasses","definitions","unknown","pseudoClassesEnabled","pseudoClassesDefinitions","pseudoClassesAcceptUnknown","_h","pseudoElements","notation","Array","isArray","NoArgument","pseudoElementsEnabled","pseudoElementsSingleColonNotationEnabled","pseudoElementsDoubleColonNotationEnabled","pseudoElementsDefinitions","pseudoElementsAcceptUnknown","str","l","pos","chr","is","comparison","isTagStart","rewind","newPos","charAt","next","readAndNext","current","fail","errorMessage","position","Math","min","error","name","assert","condition","assertNonEof","isEof","pass","character","matchMulticharIndex","index","match","matchMulticharIndexPos","subPos","char","charIndex","subMatch","chars","self","parseHex","hex","count","skipSingleWhitespace","String","fromCharCode","parseInt","parseString","quote","result","parseIdentifier","parsePseudoClassString","trim","skipWhitespace","parseSelector","relative","rules","parseRule","push","type","parseAttribute","attr","name_1","name_2","identifier","savedPos","name_3","operator","value","name_4","caseSensitivityModifier","parseNumber","isNumberStart","parseFormula","ident","firstNumber","firstNumberMultiplier","sign","parsePseudoArgument","pseudoName","signature","argument","name_5","a","b","ofSelector","selector","optional","parseTagName","name_6","parseTagNameWithNamespace","tagName","rule","items","combinator","className","idName","isDoubleColon","isPseudoElement","prototype","hasOwnProperty","call","locations","join","pseudoElement","pseudoClass","nestedRule","input"],"sources":["/Users/mubarakmuse/Abubakar-Islamic-Institute-LMS/node_modules/css-selector-parser/dist/mjs/parser.js"],"sourcesContent":["import { createMulticharIndex, createRegularIndex, emptyMulticharIndex, emptyRegularIndex } from './indexes.js';\nimport { calculatePseudoSignatures, defaultPseudoSignature, emptyPseudoSignatures } from './pseudo-signatures.js';\nimport { cssSyntaxDefinitions, extendSyntaxDefinition, getXmlOptions, cssModules, pseudoLocationIndex } from './syntax-definitions.js';\nimport { digitsChars, isHex, isIdent, isIdentStart, maxHexLength, quoteChars, whitespaceChars } from './utils.js';\nvar errorPrefix = \"css-selector-parser parse error: \";\n/**\n * Creates a parse function to be used later to parse CSS selectors.\n */\nexport function createParser(options) {\n    if (options === void 0) { options = {}; }\n    var _a = options.syntax, syntax = _a === void 0 ? 'latest' : _a, substitutes = options.substitutes, _b = options.strict, strict = _b === void 0 ? true : _b, modules = options.modules;\n    var syntaxDefinition = typeof syntax === 'object' ? syntax : cssSyntaxDefinitions[syntax];\n    if (syntaxDefinition.baseSyntax) {\n        syntaxDefinition = extendSyntaxDefinition(cssSyntaxDefinitions[syntaxDefinition.baseSyntax], syntaxDefinition);\n    }\n    // Apply modules from syntax definition\n    if (syntaxDefinition.modules && syntaxDefinition.modules.length > 0) {\n        for (var _i = 0, _c = syntaxDefinition.modules; _i < _c.length; _i++) {\n            var module_1 = _c[_i];\n            var moduleSyntax = cssModules[module_1];\n            if (moduleSyntax) {\n                syntaxDefinition = extendSyntaxDefinition(moduleSyntax, syntaxDefinition);\n            }\n        }\n    }\n    // Apply additional modules if specified from options\n    if (modules && modules.length > 0) {\n        for (var _d = 0, modules_1 = modules; _d < modules_1.length; _d++) {\n            var module_2 = modules_1[_d];\n            var moduleSyntax = cssModules[module_2];\n            if (moduleSyntax) {\n                syntaxDefinition = extendSyntaxDefinition(moduleSyntax, syntaxDefinition);\n            }\n        }\n    }\n    var _e = syntaxDefinition.tag\n        ? [true, Boolean(getXmlOptions(syntaxDefinition.tag).wildcard)]\n        : [false, false], tagNameEnabled = _e[0], tagNameWildcardEnabled = _e[1];\n    var idEnabled = Boolean(syntaxDefinition.ids);\n    var classNamesEnabled = Boolean(syntaxDefinition.classNames);\n    var namespaceEnabled = Boolean(syntaxDefinition.namespace);\n    var namespaceWildcardEnabled = syntaxDefinition.namespace &&\n        (syntaxDefinition.namespace === true || syntaxDefinition.namespace.wildcard === true);\n    if (namespaceEnabled && !tagNameEnabled) {\n        throw new Error(\"\".concat(errorPrefix, \"Namespaces cannot be enabled while tags are disabled.\"));\n    }\n    var substitutesEnabled = Boolean(substitutes);\n    var combinatorsIndex = syntaxDefinition.combinators\n        ? createMulticharIndex(syntaxDefinition.combinators)\n        : emptyMulticharIndex;\n    var _f = syntaxDefinition.attributes\n        ? [\n            true,\n            syntaxDefinition.attributes.operators\n                ? createMulticharIndex(syntaxDefinition.attributes.operators)\n                : emptyMulticharIndex,\n            syntaxDefinition.attributes.caseSensitivityModifiers\n                ? createRegularIndex(syntaxDefinition.attributes.caseSensitivityModifiers)\n                : emptyRegularIndex,\n            syntaxDefinition.attributes.unknownCaseSensitivityModifiers === 'accept'\n        ]\n        : [false, emptyMulticharIndex, emptyRegularIndex, false], attributesEnabled = _f[0], attributesOperatorsIndex = _f[1], attributesCaseSensitivityModifiers = _f[2], attributesAcceptUnknownCaseSensitivityModifiers = _f[3];\n    var attributesCaseSensitivityModifiersEnabled = attributesAcceptUnknownCaseSensitivityModifiers || Object.keys(attributesCaseSensitivityModifiers).length > 0;\n    var _g = syntaxDefinition.pseudoClasses\n        ? [\n            true,\n            syntaxDefinition.pseudoClasses.definitions\n                ? calculatePseudoSignatures(syntaxDefinition.pseudoClasses.definitions)\n                : emptyPseudoSignatures,\n            syntaxDefinition.pseudoClasses.unknown === 'accept'\n        ]\n        : [false, emptyPseudoSignatures, false], pseudoClassesEnabled = _g[0], pseudoClassesDefinitions = _g[1], pseudoClassesAcceptUnknown = _g[2];\n    var _h = syntaxDefinition.pseudoElements\n        ? [\n            true,\n            syntaxDefinition.pseudoElements.notation === 'singleColon' ||\n                syntaxDefinition.pseudoElements.notation === 'both',\n            !syntaxDefinition.pseudoElements.notation ||\n                syntaxDefinition.pseudoElements.notation === 'doubleColon' ||\n                syntaxDefinition.pseudoElements.notation === 'both',\n            syntaxDefinition.pseudoElements.definitions\n                ? calculatePseudoSignatures(Array.isArray(syntaxDefinition.pseudoElements.definitions)\n                    ? { NoArgument: syntaxDefinition.pseudoElements.definitions }\n                    : syntaxDefinition.pseudoElements.definitions)\n                : emptyPseudoSignatures,\n            syntaxDefinition.pseudoElements.unknown === 'accept'\n        ]\n        : [false, false, false, emptyPseudoSignatures, false], pseudoElementsEnabled = _h[0], pseudoElementsSingleColonNotationEnabled = _h[1], pseudoElementsDoubleColonNotationEnabled = _h[2], pseudoElementsDefinitions = _h[3], pseudoElementsAcceptUnknown = _h[4];\n    var str = '';\n    var l = str.length;\n    var pos = 0;\n    var chr = '';\n    var is = function (comparison) { return chr === comparison; };\n    var isTagStart = function () { return is('*') || isIdentStart(chr); };\n    var rewind = function (newPos) {\n        pos = newPos;\n        chr = str.charAt(pos);\n    };\n    var next = function () {\n        pos++;\n        chr = str.charAt(pos);\n    };\n    var readAndNext = function () {\n        var current = chr;\n        pos++;\n        chr = str.charAt(pos);\n        return current;\n    };\n    /** @throws ParserError */\n    function fail(errorMessage) {\n        var position = Math.min(l - 1, pos);\n        var error = new Error(\"\".concat(errorPrefix).concat(errorMessage, \" Pos: \").concat(position, \".\"));\n        error.position = position;\n        error.name = 'ParserError';\n        throw error;\n    }\n    function assert(condition, errorMessage) {\n        if (!condition) {\n            return fail(errorMessage);\n        }\n    }\n    var assertNonEof = function () {\n        assert(pos < l, 'Unexpected end of input.');\n    };\n    var isEof = function () { return pos >= l; };\n    var pass = function (character) {\n        assert(pos < l, \"Expected \\\"\".concat(character, \"\\\" but end of input reached.\"));\n        assert(chr === character, \"Expected \\\"\".concat(character, \"\\\" but \\\"\").concat(chr, \"\\\" found.\"));\n        pos++;\n        chr = str.charAt(pos);\n    };\n    function matchMulticharIndex(index) {\n        var match = matchMulticharIndexPos(index, pos);\n        if (match) {\n            pos += match.length;\n            chr = str.charAt(pos);\n            return match;\n        }\n    }\n    function matchMulticharIndexPos(index, subPos) {\n        var char = str.charAt(subPos);\n        var charIndex = index[char];\n        if (charIndex) {\n            var subMatch = matchMulticharIndexPos(charIndex.chars, subPos + 1);\n            if (subMatch) {\n                return subMatch;\n            }\n            if (charIndex.self) {\n                return charIndex.self;\n            }\n        }\n    }\n    /**\n     * @see https://www.w3.org/TR/css-syntax/#hex-digit-diagram\n     */\n    function parseHex() {\n        var hex = readAndNext();\n        var count = 1;\n        while (isHex(chr) && count < maxHexLength) {\n            hex += readAndNext();\n            count++;\n        }\n        skipSingleWhitespace();\n        return String.fromCharCode(parseInt(hex, 16));\n    }\n    /**\n     * @see https://www.w3.org/TR/css-syntax/#string-token-diagram\n     */\n    function parseString(quote) {\n        var result = '';\n        pass(quote);\n        while (pos < l) {\n            if (is(quote)) {\n                next();\n                return result;\n            }\n            else if (is('\\\\')) {\n                next();\n                if (is(quote)) {\n                    result += quote;\n                    next();\n                }\n                else if (chr === '\\n' || chr === '\\f') {\n                    next();\n                }\n                else if (chr === '\\r') {\n                    next();\n                    if (is('\\n')) {\n                        next();\n                    }\n                }\n                else if (isHex(chr)) {\n                    result += parseHex();\n                }\n                else {\n                    result += chr;\n                    next();\n                }\n            }\n            else {\n                result += chr;\n                next();\n            }\n        }\n        return result;\n    }\n    /**\n     * @see https://www.w3.org/TR/css-syntax/#ident-token-diagram\n     */\n    function parseIdentifier() {\n        if (!isIdentStart(chr)) {\n            return null;\n        }\n        var result = '';\n        while (is('-')) {\n            result += chr;\n            next();\n        }\n        if (result === '-' && !isIdent(chr) && !is('\\\\')) {\n            fail('Identifiers cannot consist of a single hyphen.');\n        }\n        if (strict && result.length >= 2) {\n            // Checking this only for strict mode since browsers work fine with these identifiers.\n            fail('Identifiers cannot start with two hyphens with strict mode on.');\n        }\n        if (digitsChars[chr]) {\n            fail('Identifiers cannot start with hyphens followed by digits.');\n        }\n        while (pos < l) {\n            if (isIdent(chr)) {\n                result += readAndNext();\n            }\n            else if (is('\\\\')) {\n                next();\n                assertNonEof();\n                if (isHex(chr)) {\n                    result += parseHex();\n                }\n                else {\n                    result += readAndNext();\n                }\n            }\n            else {\n                break;\n            }\n        }\n        return result;\n    }\n    function parsePseudoClassString() {\n        var result = '';\n        while (pos < l) {\n            if (is(')')) {\n                break;\n            }\n            else if (is('\\\\')) {\n                next();\n                if (isEof() && !strict) {\n                    return (result + '\\\\').trim();\n                }\n                assertNonEof();\n                if (isHex(chr)) {\n                    result += parseHex();\n                }\n                else {\n                    result += readAndNext();\n                }\n            }\n            else {\n                result += readAndNext();\n            }\n        }\n        return result.trim();\n    }\n    function skipSingleWhitespace() {\n        if (chr === ' ' || chr === '\\t' || chr === '\\f' || chr === '\\n') {\n            next();\n            return;\n        }\n        if (chr === '\\r') {\n            next();\n        }\n        if (chr === '\\n') {\n            next();\n        }\n    }\n    function skipWhitespace() {\n        while (whitespaceChars[chr]) {\n            next();\n        }\n    }\n    function parseSelector(relative) {\n        if (relative === void 0) { relative = false; }\n        skipWhitespace();\n        var rules = [parseRule(relative)];\n        while (is(',')) {\n            next();\n            skipWhitespace();\n            rules.push(parseRule(relative));\n        }\n        return {\n            type: 'Selector',\n            rules: rules\n        };\n    }\n    function parseAttribute() {\n        pass('[');\n        skipWhitespace();\n        var attr;\n        if (is('|')) {\n            assert(namespaceEnabled, 'Namespaces are not enabled.');\n            next();\n            var name_1 = parseIdentifier();\n            assert(name_1, 'Expected attribute name.');\n            attr = {\n                type: 'Attribute',\n                name: name_1,\n                namespace: { type: 'NoNamespace' }\n            };\n        }\n        else if (is('*')) {\n            assert(namespaceEnabled, 'Namespaces are not enabled.');\n            assert(namespaceWildcardEnabled, 'Wildcard namespace is not enabled.');\n            next();\n            pass('|');\n            var name_2 = parseIdentifier();\n            assert(name_2, 'Expected attribute name.');\n            attr = {\n                type: 'Attribute',\n                name: name_2,\n                namespace: { type: 'WildcardNamespace' }\n            };\n        }\n        else {\n            var identifier = parseIdentifier();\n            assert(identifier, 'Expected attribute name.');\n            attr = {\n                type: 'Attribute',\n                name: identifier\n            };\n            if (is('|')) {\n                var savedPos = pos;\n                next();\n                if (isIdentStart(chr)) {\n                    assert(namespaceEnabled, 'Namespaces are not enabled.');\n                    var name_3 = parseIdentifier();\n                    assert(name_3, 'Expected attribute name.');\n                    attr = {\n                        type: 'Attribute',\n                        name: name_3,\n                        namespace: { type: 'NamespaceName', name: identifier }\n                    };\n                }\n                else {\n                    rewind(savedPos);\n                }\n            }\n        }\n        assert(attr.name, 'Expected attribute name.');\n        skipWhitespace();\n        if (isEof() && !strict) {\n            return attr;\n        }\n        if (is(']')) {\n            next();\n        }\n        else {\n            attr.operator = matchMulticharIndex(attributesOperatorsIndex);\n            assert(attr.operator, 'Expected a valid attribute selector operator.');\n            skipWhitespace();\n            assertNonEof();\n            if (quoteChars[chr]) {\n                attr.value = {\n                    type: 'String',\n                    value: parseString(chr)\n                };\n            }\n            else if (substitutesEnabled && is('$')) {\n                next();\n                var name_4 = parseIdentifier();\n                assert(name_4, 'Expected substitute name.');\n                attr.value = {\n                    type: 'Substitution',\n                    name: name_4\n                };\n            }\n            else {\n                var value = parseIdentifier();\n                assert(value, 'Expected attribute value.');\n                attr.value = {\n                    type: 'String',\n                    value: value\n                };\n            }\n            skipWhitespace();\n            if (isEof() && !strict) {\n                return attr;\n            }\n            if (!is(']')) {\n                var caseSensitivityModifier = parseIdentifier();\n                assert(caseSensitivityModifier, 'Expected end of attribute selector.');\n                attr.caseSensitivityModifier = caseSensitivityModifier;\n                assert(attributesCaseSensitivityModifiersEnabled, 'Attribute case sensitivity modifiers are not enabled.');\n                assert(attributesAcceptUnknownCaseSensitivityModifiers ||\n                    attributesCaseSensitivityModifiers[attr.caseSensitivityModifier], 'Unknown attribute case sensitivity modifier.');\n                skipWhitespace();\n                if (isEof() && !strict) {\n                    return attr;\n                }\n            }\n            pass(']');\n        }\n        return attr;\n    }\n    function parseNumber() {\n        var result = '';\n        while (digitsChars[chr]) {\n            result += readAndNext();\n        }\n        assert(result !== '', 'Formula parse error.');\n        return parseInt(result);\n    }\n    var isNumberStart = function () { return is('-') || is('+') || digitsChars[chr]; };\n    function parseFormula() {\n        if (is('e') || is('o')) {\n            var ident = parseIdentifier();\n            if (ident === 'even') {\n                skipWhitespace();\n                return [2, 0];\n            }\n            if (ident === 'odd') {\n                skipWhitespace();\n                return [2, 1];\n            }\n        }\n        var firstNumber = null;\n        var firstNumberMultiplier = 1;\n        if (is('-')) {\n            next();\n            firstNumberMultiplier = -1;\n        }\n        if (isNumberStart()) {\n            if (is('+')) {\n                next();\n            }\n            firstNumber = parseNumber();\n            if (!is('\\\\') && !is('n')) {\n                return [0, firstNumber * firstNumberMultiplier];\n            }\n        }\n        if (firstNumber === null) {\n            firstNumber = 1;\n        }\n        firstNumber *= firstNumberMultiplier;\n        var identifier;\n        if (is('\\\\')) {\n            next();\n            if (isHex(chr)) {\n                identifier = parseHex();\n            }\n            else {\n                identifier = readAndNext();\n            }\n        }\n        else {\n            identifier = readAndNext();\n        }\n        assert(identifier === 'n', 'Formula parse error: expected \"n\".');\n        skipWhitespace();\n        if (is('+') || is('-')) {\n            var sign = is('+') ? 1 : -1;\n            next();\n            skipWhitespace();\n            return [firstNumber, sign * parseNumber()];\n        }\n        else {\n            return [firstNumber, 0];\n        }\n    }\n    function parsePseudoArgument(pseudoName, type, signature) {\n        var argument;\n        if (is('(')) {\n            next();\n            skipWhitespace();\n            if (substitutesEnabled && is('$')) {\n                next();\n                var name_5 = parseIdentifier();\n                assert(name_5, 'Expected substitute name.');\n                argument = {\n                    type: 'Substitution',\n                    name: name_5\n                };\n            }\n            else if (signature.type === 'String') {\n                argument = {\n                    type: 'String',\n                    value: parsePseudoClassString()\n                };\n                assert(argument.value, \"Expected \".concat(type, \" argument value.\"));\n            }\n            else if (signature.type === 'Selector') {\n                argument = parseSelector(true);\n            }\n            else if (signature.type === 'Formula') {\n                var _a = parseFormula(), a = _a[0], b = _a[1];\n                argument = {\n                    type: 'Formula',\n                    a: a,\n                    b: b\n                };\n                if (signature.ofSelector) {\n                    skipWhitespace();\n                    if (is('o') || is('\\\\')) {\n                        var ident = parseIdentifier();\n                        assert(ident === 'of', 'Formula of selector parse error.');\n                        skipWhitespace();\n                        argument = {\n                            type: 'FormulaOfSelector',\n                            a: a,\n                            b: b,\n                            selector: parseRule()\n                        };\n                    }\n                }\n            }\n            else {\n                return fail(\"Invalid \".concat(type, \" signature.\"));\n            }\n            skipWhitespace();\n            if (isEof() && !strict) {\n                return argument;\n            }\n            pass(')');\n        }\n        else {\n            assert(signature.optional, \"Argument is required for \".concat(type, \" \\\"\").concat(pseudoName, \"\\\".\"));\n        }\n        return argument;\n    }\n    function parseTagName() {\n        if (is('*')) {\n            assert(tagNameWildcardEnabled, 'Wildcard tag name is not enabled.');\n            next();\n            return { type: 'WildcardTag' };\n        }\n        else if (isIdentStart(chr)) {\n            assert(tagNameEnabled, 'Tag names are not enabled.');\n            var name_6 = parseIdentifier();\n            assert(name_6, 'Expected tag name.');\n            return {\n                type: 'TagName',\n                name: name_6\n            };\n        }\n        else {\n            return fail('Expected tag name.');\n        }\n    }\n    function parseTagNameWithNamespace() {\n        if (is('*')) {\n            var savedPos = pos;\n            next();\n            if (!is('|')) {\n                rewind(savedPos);\n                return parseTagName();\n            }\n            next();\n            if (!isTagStart()) {\n                rewind(savedPos);\n                return parseTagName();\n            }\n            assert(namespaceEnabled, 'Namespaces are not enabled.');\n            assert(namespaceWildcardEnabled, 'Wildcard namespace is not enabled.');\n            var tagName = parseTagName();\n            tagName.namespace = { type: 'WildcardNamespace' };\n            return tagName;\n        }\n        else if (is('|')) {\n            assert(namespaceEnabled, 'Namespaces are not enabled.');\n            next();\n            var tagName = parseTagName();\n            tagName.namespace = { type: 'NoNamespace' };\n            return tagName;\n        }\n        else if (isIdentStart(chr)) {\n            var identifier = parseIdentifier();\n            assert(identifier, 'Expected tag name.');\n            if (!is('|')) {\n                assert(tagNameEnabled, 'Tag names are not enabled.');\n                return {\n                    type: 'TagName',\n                    name: identifier\n                };\n            }\n            var savedPos = pos;\n            next();\n            if (!isTagStart()) {\n                rewind(savedPos);\n                return {\n                    type: 'TagName',\n                    name: identifier\n                };\n            }\n            assert(namespaceEnabled, 'Namespaces are not enabled.');\n            var tagName = parseTagName();\n            tagName.namespace = { type: 'NamespaceName', name: identifier };\n            return tagName;\n        }\n        else {\n            return fail('Expected tag name.');\n        }\n    }\n    function parseRule(relative) {\n        var _a, _b;\n        if (relative === void 0) { relative = false; }\n        var rule = { type: 'Rule', items: [] };\n        if (relative) {\n            var combinator = matchMulticharIndex(combinatorsIndex);\n            if (combinator) {\n                rule.combinator = combinator;\n                skipWhitespace();\n            }\n        }\n        while (pos < l) {\n            if (isTagStart()) {\n                assert(rule.items.length === 0, 'Unexpected tag/namespace start.');\n                rule.items.push(parseTagNameWithNamespace());\n            }\n            else if (is('|')) {\n                var savedPos = pos;\n                next();\n                if (isTagStart()) {\n                    assert(rule.items.length === 0, 'Unexpected tag/namespace start.');\n                    rewind(savedPos);\n                    rule.items.push(parseTagNameWithNamespace());\n                }\n                else {\n                    rewind(savedPos);\n                    break;\n                }\n            }\n            else if (is('.')) {\n                assert(classNamesEnabled, 'Class names are not enabled.');\n                next();\n                var className = parseIdentifier();\n                assert(className, 'Expected class name.');\n                rule.items.push({ type: 'ClassName', name: className });\n            }\n            else if (is('#')) {\n                assert(idEnabled, 'IDs are not enabled.');\n                next();\n                var idName = parseIdentifier();\n                assert(idName, 'Expected ID name.');\n                rule.items.push({ type: 'Id', name: idName });\n            }\n            else if (is('[')) {\n                assert(attributesEnabled, 'Attributes are not enabled.');\n                rule.items.push(parseAttribute());\n            }\n            else if (is(':')) {\n                var isDoubleColon = false;\n                var isPseudoElement = false;\n                next();\n                if (is(':')) {\n                    assert(pseudoElementsEnabled, 'Pseudo elements are not enabled.');\n                    assert(pseudoElementsDoubleColonNotationEnabled, 'Pseudo elements double colon notation is not enabled.');\n                    isDoubleColon = true;\n                    next();\n                }\n                var pseudoName = parseIdentifier();\n                assert(isDoubleColon || pseudoName, 'Expected pseudo-class name.');\n                assert(!isDoubleColon || pseudoName, 'Expected pseudo-element name.');\n                assert(pseudoName, 'Expected pseudo-class name.');\n                if (!isDoubleColon ||\n                    pseudoElementsAcceptUnknown ||\n                    Object.prototype.hasOwnProperty.call(pseudoElementsDefinitions, pseudoName)) {\n                    // All good\n                }\n                else {\n                    // Generate a helpful error message with location information\n                    var locations = pseudoLocationIndex.pseudoElements[pseudoName];\n                    var errorMessage = \"Unknown pseudo-element \\\"\".concat(pseudoName, \"\\\"\");\n                    if (locations && locations.length > 0) {\n                        errorMessage += \". It is defined in: \".concat(locations.join(', '));\n                    }\n                    fail(errorMessage + '.');\n                }\n                isPseudoElement =\n                    pseudoElementsEnabled &&\n                        (isDoubleColon ||\n                            (!isDoubleColon &&\n                                pseudoElementsSingleColonNotationEnabled &&\n                                Object.prototype.hasOwnProperty.call(pseudoElementsDefinitions, pseudoName)));\n                if (isPseudoElement) {\n                    var signature = (_a = pseudoElementsDefinitions[pseudoName]) !== null && _a !== void 0 ? _a : (pseudoElementsAcceptUnknown && defaultPseudoSignature);\n                    var pseudoElement = {\n                        type: 'PseudoElement',\n                        name: pseudoName\n                    };\n                    var argument = parsePseudoArgument(pseudoName, 'pseudo-element', signature);\n                    if (argument) {\n                        assert(argument.type !== 'Formula' && argument.type !== 'FormulaOfSelector', 'Pseudo-elements cannot have formula argument.');\n                        pseudoElement.argument = argument;\n                    }\n                    rule.items.push(pseudoElement);\n                }\n                else {\n                    assert(pseudoClassesEnabled, 'Pseudo-classes are not enabled.');\n                    var signature = (_b = pseudoClassesDefinitions[pseudoName]) !== null && _b !== void 0 ? _b : (pseudoClassesAcceptUnknown && defaultPseudoSignature);\n                    if (signature) {\n                        // All good\n                    }\n                    else {\n                        // Generate a helpful error message with location information\n                        var locations = pseudoLocationIndex.pseudoClasses[pseudoName];\n                        var errorMessage = \"Unknown pseudo-class: \\\"\".concat(pseudoName, \"\\\"\");\n                        if (locations && locations.length > 0) {\n                            errorMessage += \". It is defined in: \".concat(locations.join(', '));\n                        }\n                        fail(errorMessage + '.');\n                    }\n                    var argument = parsePseudoArgument(pseudoName, 'pseudo-class', signature);\n                    var pseudoClass = {\n                        type: 'PseudoClass',\n                        name: pseudoName\n                    };\n                    if (argument) {\n                        pseudoClass.argument = argument;\n                    }\n                    rule.items.push(pseudoClass);\n                }\n            }\n            else {\n                break;\n            }\n        }\n        if (rule.items.length === 0) {\n            if (isEof()) {\n                return fail('Expected rule but end of input reached.');\n            }\n            else {\n                return fail(\"Expected rule but \\\"\".concat(chr, \"\\\" found.\"));\n            }\n        }\n        skipWhitespace();\n        if (!isEof() && !is(',') && !is(')')) {\n            var combinator = matchMulticharIndex(combinatorsIndex);\n            skipWhitespace();\n            rule.nestedRule = parseRule();\n            rule.nestedRule.combinator = combinator;\n        }\n        return rule;\n    }\n    return function (input) {\n        // noinspection SuspiciousTypeOfGuard\n        if (typeof input !== 'string') {\n            throw new Error(\"\".concat(errorPrefix, \"Expected string input.\"));\n        }\n        str = input;\n        l = str.length;\n        pos = 0;\n        chr = str.charAt(0);\n        return parseSelector();\n    };\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}