{"ast":null,"code":"export var emptyPseudoSignatures = {};\nexport var defaultPseudoSignature = {\n  type: 'String',\n  optional: true\n};\nfunction calculatePseudoSignature(types) {\n  var result = {\n    type: 'NoArgument',\n    optional: false\n  };\n  function setResultType(type) {\n    if (result.type && result.type !== type && result.type !== 'NoArgument') {\n      throw new Error(\"Conflicting pseudo-class argument type: \\\"\".concat(result.type, \"\\\" vs \\\"\").concat(type, \"\\\".\"));\n    }\n    result.type = type;\n  }\n  for (var _i = 0, types_1 = types; _i < types_1.length; _i++) {\n    var type = types_1[_i];\n    if (type === 'NoArgument') {\n      result.optional = true;\n    }\n    if (type === 'Formula') {\n      setResultType('Formula');\n    }\n    if (type === 'FormulaOfSelector') {\n      setResultType('Formula');\n      result.ofSelector = true;\n    }\n    if (type === 'String') {\n      setResultType('String');\n    }\n    if (type === 'Selector') {\n      setResultType('Selector');\n    }\n  }\n  return result;\n}\nexport function inverseCategories(obj) {\n  var result = {};\n  for (var _i = 0, _a = Object.keys(obj); _i < _a.length; _i++) {\n    var category = _a[_i];\n    var items = obj[category];\n    if (items) {\n      for (var _b = 0, _c = items; _b < _c.length; _b++) {\n        var item = _c[_b];\n        (result[item] || (result[item] = [])).push(category);\n      }\n    }\n  }\n  return result;\n}\nexport function calculatePseudoSignatures(definitions) {\n  var pseudoClassesToArgumentTypes = inverseCategories(definitions);\n  var result = {};\n  for (var _i = 0, _a = Object.keys(pseudoClassesToArgumentTypes); _i < _a.length; _i++) {\n    var pseudoClass = _a[_i];\n    var argumentTypes = pseudoClassesToArgumentTypes[pseudoClass];\n    if (argumentTypes) {\n      result[pseudoClass] = calculatePseudoSignature(argumentTypes);\n    }\n  }\n  return result;\n}","map":{"version":3,"names":["emptyPseudoSignatures","defaultPseudoSignature","type","optional","calculatePseudoSignature","types","result","setResultType","Error","concat","_i","types_1","length","ofSelector","inverseCategories","obj","_a","Object","keys","category","items","_b","_c","item","push","calculatePseudoSignatures","definitions","pseudoClassesToArgumentTypes","pseudoClass","argumentTypes"],"sources":["/Users/mubarakmuse/Abubakar-Islamic-Institute-LMS/node_modules/css-selector-parser/dist/mjs/pseudo-signatures.js"],"sourcesContent":["export var emptyPseudoSignatures = {};\nexport var defaultPseudoSignature = {\n    type: 'String',\n    optional: true\n};\nfunction calculatePseudoSignature(types) {\n    var result = {\n        type: 'NoArgument',\n        optional: false\n    };\n    function setResultType(type) {\n        if (result.type && result.type !== type && result.type !== 'NoArgument') {\n            throw new Error(\"Conflicting pseudo-class argument type: \\\"\".concat(result.type, \"\\\" vs \\\"\").concat(type, \"\\\".\"));\n        }\n        result.type = type;\n    }\n    for (var _i = 0, types_1 = types; _i < types_1.length; _i++) {\n        var type = types_1[_i];\n        if (type === 'NoArgument') {\n            result.optional = true;\n        }\n        if (type === 'Formula') {\n            setResultType('Formula');\n        }\n        if (type === 'FormulaOfSelector') {\n            setResultType('Formula');\n            result.ofSelector = true;\n        }\n        if (type === 'String') {\n            setResultType('String');\n        }\n        if (type === 'Selector') {\n            setResultType('Selector');\n        }\n    }\n    return result;\n}\nexport function inverseCategories(obj) {\n    var result = {};\n    for (var _i = 0, _a = Object.keys(obj); _i < _a.length; _i++) {\n        var category = _a[_i];\n        var items = obj[category];\n        if (items) {\n            for (var _b = 0, _c = items; _b < _c.length; _b++) {\n                var item = _c[_b];\n                (result[item] || (result[item] = [])).push(category);\n            }\n        }\n    }\n    return result;\n}\nexport function calculatePseudoSignatures(definitions) {\n    var pseudoClassesToArgumentTypes = inverseCategories(definitions);\n    var result = {};\n    for (var _i = 0, _a = Object.keys(pseudoClassesToArgumentTypes); _i < _a.length; _i++) {\n        var pseudoClass = _a[_i];\n        var argumentTypes = pseudoClassesToArgumentTypes[pseudoClass];\n        if (argumentTypes) {\n            result[pseudoClass] = calculatePseudoSignature(argumentTypes);\n        }\n    }\n    return result;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}