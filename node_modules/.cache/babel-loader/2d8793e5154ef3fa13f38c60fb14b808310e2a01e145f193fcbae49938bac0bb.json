{"ast":null,"code":"export function selectWord(_ref) {\n  var {\n    text,\n    selection,\n    prefix,\n    suffix = prefix\n  } = _ref;\n  var result = selection;\n  if (text && text.length && selection.start === selection.end) {\n    result = getSurroundingWord(text, selection.start);\n  }\n  if (result.start >= prefix.length && result.end <= text.length - suffix.length) {\n    var selectedTextContext = text.slice(result.start - prefix.length, result.end + suffix.length);\n    if (selectedTextContext.startsWith(prefix) && selectedTextContext.endsWith(suffix)) {\n      return {\n        start: result.start - prefix.length,\n        end: result.end + suffix.length\n      };\n    }\n  }\n  return result;\n}\nexport function selectLine(_ref2) {\n  var {\n    text,\n    selection\n  } = _ref2;\n  var start = text.slice(0, selection.start).lastIndexOf('\\n') + 1;\n  var end = text.slice(selection.end).indexOf('\\n') + selection.end;\n  if (end === selection.end - 1) {\n    end = text.length;\n  }\n  return {\n    start,\n    end\n  };\n}\n\n/**\n *  Gets the number of line-breaks that would have to be inserted before the given 'startPosition'\n *  to make sure there's an empty line between 'startPosition' and the previous text\n */\nexport function getBreaksNeededForEmptyLineBefore(text, startPosition) {\n  if (text === void 0) {\n    text = '';\n  }\n  if (startPosition === 0) return 0;\n\n  // rules:\n  // - If we're in the first line, no breaks are needed\n  // - Otherwise there must be 2 breaks before the previous character. Depending on how many breaks exist already, we\n  //      may need to insert 0, 1 or 2 breaks\n\n  var neededBreaks = 2;\n  var isInFirstLine = true;\n  for (var i = startPosition - 1; i >= 0 && neededBreaks >= 0; i--) {\n    switch (text.charCodeAt(i)) {\n      case 32:\n        // blank space\n        continue;\n      case 10:\n        // line break\n        neededBreaks--;\n        isInFirstLine = false;\n        break;\n      default:\n        return neededBreaks;\n    }\n  }\n  return isInFirstLine ? 0 : neededBreaks;\n}\n\n/**\n *  Gets the number of line-breaks that would have to be inserted after the given 'startPosition'\n *  to make sure there's an empty line between 'startPosition' and the next text\n */\nexport function getBreaksNeededForEmptyLineAfter(text, startPosition) {\n  if (text === void 0) {\n    text = '';\n  }\n  if (startPosition === text.length - 1) return 0;\n\n  // rules:\n  // - If we're in the first line, no breaks are needed\n  // - Otherwise there must be 2 breaks before the previous character. Depending on how many breaks exist already, we\n  //      may need to insert 0, 1 or 2 breaks\n\n  var neededBreaks = 2;\n  var isInLastLine = true;\n  for (var i = startPosition; i < text.length && neededBreaks >= 0; i++) {\n    switch (text.charCodeAt(i)) {\n      case 32:\n        continue;\n      case 10:\n        {\n          neededBreaks--;\n          isInLastLine = false;\n          break;\n        }\n      default:\n        return neededBreaks;\n    }\n  }\n  return isInLastLine ? 0 : neededBreaks;\n}\nexport function getSurroundingWord(text, position) {\n  if (!text) throw Error(\"Argument 'text' should be truthy\");\n  var isWordDelimiter = c => c === ' ' || c.charCodeAt(0) === 10;\n\n  // leftIndex is initialized to 0 because if selection is 0, it won't even enter the iteration\n  var start = 0;\n  // rightIndex is initialized to text.length because if selection is equal to text.length it won't even enter the interation\n  var end = text.length;\n\n  // iterate to the left\n  for (var i = position; i - 1 > -1; i--) {\n    if (isWordDelimiter(text[i - 1])) {\n      start = i;\n      break;\n    }\n  }\n\n  // iterate to the right\n  for (var _i = position; _i < text.length; _i++) {\n    if (isWordDelimiter(text[_i])) {\n      end = _i;\n      break;\n    }\n  }\n  return {\n    start,\n    end\n  };\n}\nexport function executeCommand(_ref3) {\n  var {\n    api,\n    selectedText,\n    selection,\n    prefix,\n    suffix = prefix\n  } = _ref3;\n  if (selectedText.length >= prefix.length + suffix.length && selectedText.startsWith(prefix) && selectedText.endsWith(suffix)) {\n    api.replaceSelection(selectedText.slice(prefix.length, suffix.length ? -suffix.length : undefined));\n    api.setSelectionRange({\n      start: selection.start - prefix.length,\n      end: selection.end - prefix.length\n    });\n  } else {\n    api.replaceSelection(\"\" + prefix + selectedText + suffix);\n    api.setSelectionRange({\n      start: selection.start + prefix.length,\n      end: selection.end + prefix.length\n    });\n  }\n}\n/**\n * Inserts insertionString before each line\n */\nexport function insertBeforeEachLine(selectedText, insertBefore) {\n  var lines = selectedText.split(/\\n/);\n  var insertionLength = 0;\n  var modifiedText = lines.map((item, index) => {\n    if (typeof insertBefore === 'string') {\n      if (item.startsWith(insertBefore)) {\n        insertionLength -= insertBefore.length;\n        return item.slice(insertBefore.length);\n      }\n      insertionLength += insertBefore.length;\n      return insertBefore + item;\n    }\n    if (typeof insertBefore === 'function') {\n      if (item.startsWith(insertBefore(item, index))) {\n        insertionLength -= insertBefore(item, index).length;\n        return item.slice(insertBefore(item, index).length);\n      }\n      var insertionResult = insertBefore(item, index);\n      insertionLength += insertionResult.length;\n      return insertBefore(item, index) + item;\n    }\n    throw Error('insertion is expected to be either a string or a function');\n  }).join('\\n');\n  return {\n    modifiedText,\n    insertionLength\n  };\n}","map":{"version":3,"names":["selectWord","_ref","text","selection","prefix","suffix","result","length","start","end","getSurroundingWord","selectedTextContext","slice","startsWith","endsWith","selectLine","_ref2","lastIndexOf","indexOf","getBreaksNeededForEmptyLineBefore","startPosition","neededBreaks","isInFirstLine","i","charCodeAt","getBreaksNeededForEmptyLineAfter","isInLastLine","position","Error","isWordDelimiter","c","_i","executeCommand","_ref3","api","selectedText","replaceSelection","undefined","setSelectionRange","insertBeforeEachLine","insertBefore","lines","split","insertionLength","modifiedText","map","item","index","insertionResult","join"],"sources":["/Users/mubarakmuse/Abubakar-Islamic-Institute-LMS/node_modules/@uiw/react-md-editor/esm/utils/markdownUtils.js"],"sourcesContent":["export function selectWord(_ref) {\n  var {\n    text,\n    selection,\n    prefix,\n    suffix = prefix\n  } = _ref;\n  var result = selection;\n  if (text && text.length && selection.start === selection.end) {\n    result = getSurroundingWord(text, selection.start);\n  }\n  if (result.start >= prefix.length && result.end <= text.length - suffix.length) {\n    var selectedTextContext = text.slice(result.start - prefix.length, result.end + suffix.length);\n    if (selectedTextContext.startsWith(prefix) && selectedTextContext.endsWith(suffix)) {\n      return {\n        start: result.start - prefix.length,\n        end: result.end + suffix.length\n      };\n    }\n  }\n  return result;\n}\nexport function selectLine(_ref2) {\n  var {\n    text,\n    selection\n  } = _ref2;\n  var start = text.slice(0, selection.start).lastIndexOf('\\n') + 1;\n  var end = text.slice(selection.end).indexOf('\\n') + selection.end;\n  if (end === selection.end - 1) {\n    end = text.length;\n  }\n  return {\n    start,\n    end\n  };\n}\n\n/**\n *  Gets the number of line-breaks that would have to be inserted before the given 'startPosition'\n *  to make sure there's an empty line between 'startPosition' and the previous text\n */\nexport function getBreaksNeededForEmptyLineBefore(text, startPosition) {\n  if (text === void 0) {\n    text = '';\n  }\n  if (startPosition === 0) return 0;\n\n  // rules:\n  // - If we're in the first line, no breaks are needed\n  // - Otherwise there must be 2 breaks before the previous character. Depending on how many breaks exist already, we\n  //      may need to insert 0, 1 or 2 breaks\n\n  var neededBreaks = 2;\n  var isInFirstLine = true;\n  for (var i = startPosition - 1; i >= 0 && neededBreaks >= 0; i--) {\n    switch (text.charCodeAt(i)) {\n      case 32:\n        // blank space\n        continue;\n      case 10:\n        // line break\n        neededBreaks--;\n        isInFirstLine = false;\n        break;\n      default:\n        return neededBreaks;\n    }\n  }\n  return isInFirstLine ? 0 : neededBreaks;\n}\n\n/**\n *  Gets the number of line-breaks that would have to be inserted after the given 'startPosition'\n *  to make sure there's an empty line between 'startPosition' and the next text\n */\nexport function getBreaksNeededForEmptyLineAfter(text, startPosition) {\n  if (text === void 0) {\n    text = '';\n  }\n  if (startPosition === text.length - 1) return 0;\n\n  // rules:\n  // - If we're in the first line, no breaks are needed\n  // - Otherwise there must be 2 breaks before the previous character. Depending on how many breaks exist already, we\n  //      may need to insert 0, 1 or 2 breaks\n\n  var neededBreaks = 2;\n  var isInLastLine = true;\n  for (var i = startPosition; i < text.length && neededBreaks >= 0; i++) {\n    switch (text.charCodeAt(i)) {\n      case 32:\n        continue;\n      case 10:\n        {\n          neededBreaks--;\n          isInLastLine = false;\n          break;\n        }\n      default:\n        return neededBreaks;\n    }\n  }\n  return isInLastLine ? 0 : neededBreaks;\n}\nexport function getSurroundingWord(text, position) {\n  if (!text) throw Error(\"Argument 'text' should be truthy\");\n  var isWordDelimiter = c => c === ' ' || c.charCodeAt(0) === 10;\n\n  // leftIndex is initialized to 0 because if selection is 0, it won't even enter the iteration\n  var start = 0;\n  // rightIndex is initialized to text.length because if selection is equal to text.length it won't even enter the interation\n  var end = text.length;\n\n  // iterate to the left\n  for (var i = position; i - 1 > -1; i--) {\n    if (isWordDelimiter(text[i - 1])) {\n      start = i;\n      break;\n    }\n  }\n\n  // iterate to the right\n  for (var _i = position; _i < text.length; _i++) {\n    if (isWordDelimiter(text[_i])) {\n      end = _i;\n      break;\n    }\n  }\n  return {\n    start,\n    end\n  };\n}\nexport function executeCommand(_ref3) {\n  var {\n    api,\n    selectedText,\n    selection,\n    prefix,\n    suffix = prefix\n  } = _ref3;\n  if (selectedText.length >= prefix.length + suffix.length && selectedText.startsWith(prefix) && selectedText.endsWith(suffix)) {\n    api.replaceSelection(selectedText.slice(prefix.length, suffix.length ? -suffix.length : undefined));\n    api.setSelectionRange({\n      start: selection.start - prefix.length,\n      end: selection.end - prefix.length\n    });\n  } else {\n    api.replaceSelection(\"\" + prefix + selectedText + suffix);\n    api.setSelectionRange({\n      start: selection.start + prefix.length,\n      end: selection.end + prefix.length\n    });\n  }\n}\n/**\n * Inserts insertionString before each line\n */\nexport function insertBeforeEachLine(selectedText, insertBefore) {\n  var lines = selectedText.split(/\\n/);\n  var insertionLength = 0;\n  var modifiedText = lines.map((item, index) => {\n    if (typeof insertBefore === 'string') {\n      if (item.startsWith(insertBefore)) {\n        insertionLength -= insertBefore.length;\n        return item.slice(insertBefore.length);\n      }\n      insertionLength += insertBefore.length;\n      return insertBefore + item;\n    }\n    if (typeof insertBefore === 'function') {\n      if (item.startsWith(insertBefore(item, index))) {\n        insertionLength -= insertBefore(item, index).length;\n        return item.slice(insertBefore(item, index).length);\n      }\n      var insertionResult = insertBefore(item, index);\n      insertionLength += insertionResult.length;\n      return insertBefore(item, index) + item;\n    }\n    throw Error('insertion is expected to be either a string or a function');\n  }).join('\\n');\n  return {\n    modifiedText,\n    insertionLength\n  };\n}"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}